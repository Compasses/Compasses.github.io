<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 三十重围</title>
    <link>http://compasses.github.io/post/</link>
    <description>Recent content in Posts on 三十重围</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-EN</language>
    <managingEditor>gnhe2009@gmail.com (Jet He)</managingEditor>
    <webMaster>gnhe2009@gmail.com (Jet He)</webMaster>
    <copyright>(c) 2015 Jet He.</copyright>
    <lastBuildDate>Wed, 27 Jan 2016 15:51:02 +0800</lastBuildDate>
    <atom:link href="http://compasses.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>input 和 textarea的长度限制问题</title>
      <link>http://compasses.github.io/2016/01/27/input-%E5%92%8C-textarea%E7%9A%84%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6%E9%97%AE%E9%A2%98/</link>
      <pubDate>Wed, 27 Jan 2016 15:51:02 +0800</pubDate>
      <author>gnhe2009@gmail.com (Jet He)</author>
      <guid>http://compasses.github.io/2016/01/27/input-%E5%92%8C-textarea%E7%9A%84%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6%E9%97%AE%E9%A2%98/</guid>
      <description>

&lt;p&gt;一些敏感的页面应用，对用户的输入都有较多的限制，长度便是其中之一。但是最近遇到一个长度限制的问题。HTML对 input 和 textarea都有maxlength 的属性，该属性的解释就是&lt;a href=&#34;http://www.w3school.com.cn/tags/att_input_maxlength.asp&#34;&gt;允许输入字段的最大字符数&lt;/a&gt;。这里说的字符数，对英文是完全没有问题的，能做到精确控制输入长度，但是汉字的长度就会有前后不一致的问题。&lt;/p&gt;

&lt;h2 id=&#34;编码问题&#34;&gt;编码问题&lt;/h2&gt;

&lt;p&gt;互联网上使用最为广泛的就是UTF-8的编码方式，查看网页源码的时候基本上都能看到字符集的编码设置：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;meta charset=&amp;quot;utf-8&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;UTF-8是Unicode的一种实现方式。是一种变长编码，想更多了解的可以看&lt;a href=&#34;http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html&#34;&gt;这篇文章&lt;/a&gt;，基本上能让大家明白。所以造成这个问题的主因也是由于变长编码导致的。javascript把每个汉字当成一个字符，而在后台PHP是按照UTF-8计算，每个汉字由三个字节组成，故中文输入到了后台长度会变成字数的三倍。所以在输入框里面有中文的时候maxlength限制就不再可靠了。&lt;/p&gt;

&lt;h2 id=&#34;精确获取字符长度&#34;&gt;精确获取字符长度&lt;/h2&gt;

&lt;p&gt;由于maxlength不再可靠，需要有方法获取任意输入的字节数。针对中文输入使用将其转码并使用特殊方法计算其长度便可达成精确控制输入长度的目的。&lt;strong&gt;encodeURIComponent&lt;/strong&gt;方法是比较好用的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;The encodeURIComponent() function encodes a Uniform Resource Identifier (URI) component by replacing each instance of certain characters by one, two, three, or four escape sequences representing the UTF-8 encoding of the character (will only be four escape sequences for characters composed of two &amp;quot;surrogate&amp;quot; characters).
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该方法能将UTF-8编码的输入文字转码成对应的多字节字符串。
例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;encodeURIComponent(&#39;我的问题&#39;)
&amp;quot;%E6%88%91%E7%9A%84%E9%97%AE%E9%A2%98&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;每个中文字转成三个字节冠以%开头。匹配出这样的pattern并计算长度，使用javascript的正则表达式:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/%[A-F\d]{2}/g
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;并临时替换成一个英文字符，那么长度就可以准确得到了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;encodeURIComponent(&#39;abc我的问题abc&#39;).replace(/%[A-F\d]{2}/g, &#39;i&#39;)
&amp;quot;abciiiiiiiiiiiiabc&amp;quot;
encodeURIComponent(&#39;abc我的问题abc&#39;).replace(/%[A-F\d]{2}/g, &#39;i&#39;).length
18
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;textarea-中的换行符&#34;&gt;textarea 中的换行符&lt;/h2&gt;

&lt;p&gt;与input相比，textarea还能输入回车换行，但是换行在javascript计算长度的时候却少计算一个字符，这样也会造成跟PHP后台不一致的情况，其实java后台也是一样的。
例如只有一个换行符的encode前端结果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;encodeURIComponent($(&#39;textarea&#39;).val())
&amp;quot;%0A&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而到了后台该换行符变成：&lt;strong&gt;0D 0A&lt;/strong&gt;。
产生这个问题的原因是换行符在HTTP&lt;a href=&#34;http://stackoverflow.com/questions/462348/string-length-differs-from-javascript-to-java-code&#34;&gt;传输的过程中发生转换&lt;/a&gt;，由‘\n’变成‘\r\n’。
因此在计算textarea值时在遇到换行符时记得长度额外加1。&lt;/p&gt;

&lt;h2 id=&#34;代码实现&#34;&gt;代码实现&lt;/h2&gt;

&lt;p&gt;既然问题原因找到了，解决的思路也基本清晰了，剩下的就是JS代码实现下了。
针对input：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $(&amp;quot;input&amp;quot;).on(&#39;keydown keyup paste&#39;,function(){
        var $that = $(this),
        maxlength = $that.attr(&#39;maxlength&#39;);

        if($.isNumeric(maxlength) &amp;amp;&amp;amp; maxlength &amp;gt; 0){
            var realLen = encodeURIComponent($that.val()).replace(/%[A-F\d]{2}/g, &#39;U&#39;).length;
            var currLen = $that.val().length;
            if (realLen &amp;gt; maxlength) {
                do {
                    $that.val($that.val().substr(0, currLen));
                    currLen --;
                } while (encodeURIComponent($that.val()).replace(/%[A-F\d]{2}/g, &#39;U&#39;).length &amp;gt; maxlength);
            }
        };
    });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;针对textarea：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $(&amp;quot;textarea&amp;quot;).on(&#39;keydown keyup paste&#39;,function(){
        var $that = $(this),
        maxlength = $that.attr(&#39;maxlength&#39;);

        if($.isNumeric(maxlength) &amp;amp;&amp;amp; maxlength &amp;gt; 0){
            var realLen = encodeURIComponent($that.val()).replace(/%[A-F\d]{2}/g, &#39;U&#39;).length;
            var newLines = $that.val().match(/(\r\n|\n|\r)/g);

            if (newLines !== null) {
                realLen += newLines.length;
            }
            var currLen = $that.val().length;
            if (realLen &amp;gt; maxlength) {
                do {
                    $that.val($that.val().substr(0, currLen));
                    currLen --;
                    realLen = encodeURIComponent($that.val()).replace(/%[A-F\d]{2}/g, &#39;U&#39;).length;
                    newLines = $that.val().match(/(\r\n|\n|\r)/g);
                    if (newLines !== null) {
                        realLen += newLines.length;
                    }
                } while (realLen &amp;gt; maxlength);
            }
        };
    });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上述代码已完整测试，中文、英文、中英文混合、复制粘贴等等，都能按照maxlength的值精确控制用户输入的长度了。&lt;/p&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;见微知著，看似不大的问题却涵盖很广的知识面。就是这样，注意细节问题，才能不断进步。厚积薄发，注意小问题，更不轻易放过，放过了小问题，对你来说就是大问题了。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>系统性能 一</title>
      <link>http://compasses.github.io/2016/01/18/%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD-%E4%B8%80/</link>
      <pubDate>Mon, 18 Jan 2016 19:15:00 +0800</pubDate>
      <author>gnhe2009@gmail.com (Jet He)</author>
      <guid>http://compasses.github.io/2016/01/18/%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD-%E4%B8%80/</guid>
      <description>

&lt;p&gt;最近一直在做系统性能优化，包括性能问题定位，系统整体性能提升等。在性能测试环境上一边测试一边优化，从最开始的表象开始，修改代码和各种系统参数，然后就会出现新的表象，然后再修改代码和系统参数。性能测试涉及的节点很多，很多方面都有联动性，最后辛辛苦苦的搞了大半个月，确实有所进展但是总感觉缺少系统的方法。今天有幸看到这样的一篇文章&lt;a href=&#34;http://techblog.netflix.com/2015/11/linux-performance-analysis-in-60s.html&#34;&gt;Linux Performance Analysis in 60,000 Milliseconds&lt;/a&gt;，明确了在一个server上面，最开始你应该关注到什么。虽然里面的东西大家都有注意，但是可能还是不够全面。现在就结合这篇文章和自己的实践做下总结吧。&lt;/p&gt;

&lt;h2 id=&#34;uptime&#34;&gt;uptime&lt;/h2&gt;

&lt;p&gt;首先出场的便是&lt;strong&gt;uptime&lt;/strong&gt;这个命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@ip-172-31-3-207:~# uptime
 02:15:06 up 48 days, 18:01,  3 users,  load average: 65.43, 17.08, 5.81
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个命令明确告诉我们当前系统的时间，启动运行了多长时间，用户的登录数，以及当前系统分别在 1，5，15分钟内的进程平均数量，这些进程数量表示运行中或者处于不可中断的状态。这个命令是非常high level的总结，说明总体的系统负载情况。&lt;/p&gt;

&lt;h2 id=&#34;dmesg-tail&#34;&gt;dmesg|tail&lt;/h2&gt;

&lt;p&gt;个人比较喜欢这个dmesg命令，一般是内核的日志，会有一些重要的信息抛出。例如进程异常退出，因为内存耗尽或者进程crash。还会记录些命令操作的异常。值得好好利用的命令。&lt;/p&gt;

&lt;h2 id=&#34;vmstat-1&#34;&gt;vmstat 1&lt;/h2&gt;

&lt;p&gt;系统虚拟内存的统计信息，1表示没1秒输出一次。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@cnpvgvb1od042:~/PCP# vmstat 2
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 1  0      0 9818904   1820 3563052    0    0     0     2    0    0  0  0 100  0  0
 1  0      0 9842332   1820 3563104    0    0     0    98 4195 6788 41  4 55  0  0
 0  0      0 9888940   1820 3563124    0    0     0     0 1886 3149 15  2 83  0  0
 5  0      0 9917440   1820 3563104    0    0     0     0 3549 6524 31  4 66  0  0
15  0      0 9961216   1820 3563156    0    0     0    34 6469 11150 70  8 22  0  0
 5  0      0 9998920   1820 3563236    0    0     0     0 4350 7398 49  5 45  0  0
 2  0      0 10038652   1820 3563260    0    0     0    58 2922 4788 28  3 69  0  0
 4  0      0 10070480   1820 3563244    0    0     0  1252 2305 4215 14  2 84  0  0
 1  0      0 10100696   1820 3563284    0    0     0     0 2683 4405 14  2 84  0  0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;几个重要的列：&lt;/p&gt;

&lt;p&gt;r: 正在运行或者等待运行的进程数。该数量不包含I/O的进程。CPU是否饱和，就看这个数量是否多余CPU核的数量。&lt;/p&gt;

&lt;p&gt;free:剩余内存以kb为单位。&lt;/p&gt;

&lt;p&gt;si，so：换入换出，如果这些值非0，那么说明内存不足。&lt;/p&gt;

&lt;p&gt;us, sy, id, wa, st: 这几项表明当前CPU的繁忙程度。分别代表了用户时间，系统时间，空闲时间，wait IO时间和stolen time。需要注意的是system time也有IO处理的时间。如果比较高的系统时间占用说明内核处理IO不够高效。&lt;/p&gt;

&lt;h2 id=&#34;mpstat-p-all-1&#34;&gt;mpstat -P ALL 1&lt;/h2&gt;

&lt;p&gt;这个命令每个CPU的使用率情况，如果有单核CPU过载的情况，说明线程的任务分配有问题。需要做相应的调整。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;02:28:54 PM  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
02:28:56 PM  all   85.62    0.00    6.00    0.00    1.81    0.00    0.00    0.00    0.00    6.57
02:28:56 PM    0   85.00    0.00    7.50    0.50    0.50    0.00    0.00    0.00    0.00    6.50
02:28:56 PM    1   87.94    0.00    5.53    0.00    0.50    0.00    0.00    0.00    0.00    6.03
02:28:56 PM    2   77.50    0.00    8.00    0.00   10.50    0.00    0.00    0.00    0.00    4.00
02:28:56 PM    3   89.39    0.00    5.05    0.00    0.51    0.00    0.00    0.00    0.00    5.05
02:28:56 PM    4   87.00    0.00    5.50    0.00    0.50    0.00    0.00    0.00    0.00    7.00
02:28:56 PM    5   87.00    0.00    6.00    0.00    0.50    0.00    0.00    0.00    0.00    6.50
02:28:56 PM    6   84.16    0.00    5.45    0.00    0.99    0.00    0.00    0.00    0.00    9.41
02:28:56 PM    7   86.93    0.00    5.03    0.00    0.50    0.00    0.00    0.00    0.00    7.54
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;pidstat-1&#34;&gt;pidstat 1&lt;/h2&gt;

&lt;p&gt;用这个命令可以观察到单个进程的运行情况。并且每个CPU会单独列出。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;02:44:55 PM   UID       PID    %usr %system  %guest    %CPU   CPU  Command
02:44:57 PM     0         3    0.00    0.50    0.00    0.50     0  ksoftirqd/0
02:44:57 PM     0      6775    1.00    1.50    0.00    2.50     1  pidstat
02:44:57 PM 65534      9303    0.50    0.50    0.00    1.00     3  nginx
02:44:57 PM 65534      9304    1.00    0.50    0.00    1.50     5  nginx
02:44:57 PM 65534      9305    0.50    0.50    0.00    1.00     0  nginx
02:44:57 PM 65534      9306    0.00    0.50    0.00    0.50     0  nginx
02:44:57 PM 65534      9307    1.00    0.00    0.00    1.00     5  nginx
02:44:57 PM 65534      9308    0.50    0.00    0.00    0.50     7  nginx
02:44:57 PM 65534      9309    0.50    0.50    0.00    1.00     0  nginx
02:44:57 PM 65534      9310    0.50    0.50    0.00    1.00     7  nginx
02:44:57 PM   101     11711   10.50    4.50    0.00   15.00     1  beam.smp
02:44:57 PM   101     11743   29.50   26.00    0.00   55.50     6  child_setup
02:44:57 PM   101     11744   27.50   24.50    0.00   52.00     2  child_setup
02:44:57 PM     0     12083    0.00    0.50    0.00    0.50     3  kworker/3:1
02:44:57 PM     0     13591    0.00    0.50    0.00    0.50     5  btrfs-endio-wri
02:44:57 PM     0     14886    0.50    0.00    0.00    0.50     5  sshd
02:44:57 PM     0     16455    0.00    0.50    0.00    0.50     7  python
02:44:57 PM     0     18623    2.50    6.50    0.00    9.00     4  docker
02:44:57 PM     0     18665    1.50    3.50    0.00    5.00     0  redis-server
02:44:57 PM     0     19366    2.00    1.50    0.00    3.50     3  beam.smp
02:44:57 PM     0     22995    4.00    3.50    0.00    7.50     1  java
02:44:57 PM     0     23112    0.50    0.00    0.00    0.50     1  supervisord
02:44:57 PM   101     23264    2.00    2.00    0.00    4.00     1  beam.smp
02:44:57 PM   105     24078    1.00    1.00    0.00    2.00     1  mysqld
02:44:57 PM     0     26109    0.00    0.50    0.00    0.50     0  java
02:44:57 PM     0     27157    1.00    0.00    0.00    1.00     2  java
02:44:57 PM     0     30423    1.50    0.00    0.00    1.50     0  java
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;iostat-xz-1&#34;&gt;iostat -xz 1&lt;/h2&gt;

&lt;p&gt;iostat 较好的反映IO密集型应用的负载情况。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;avg-cpu:  %user   %nice %system %iowait  %steal   %idle
          61.22    0.00    5.58    0.06    0.00   33.15

Device:         rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util
sda               0.00     6.00    0.00   13.00     0.00  1364.00   209.85     0.03    2.00    0.00    2.00   0.77   1.00
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;r/s, w/s, rkB/s, wkB/s: 顾名思义，分别表示每秒钟读、写的次数和读写的kB数。&lt;/p&gt;

&lt;p&gt;await: 是IO的平均时间，单位为ms。这个过大的话表明设备负载饱和了，或者设备有故障。&lt;/p&gt;

&lt;p&gt;avgqu-sz: 是对设备的平均请求数，大于1的话表明有一定的饱和了。&lt;/p&gt;

&lt;p&gt;%util：用时的百分比。表示没秒钟有多少时间花在了IO上。一般这个超过60%说明IO性能有问题了。&lt;/p&gt;

&lt;p&gt;针对IO的优化需要做到IO的异步处理即可。使得应用不直接阻塞在慢响应上面。适用的技术：提前读、写缓存。&lt;/p&gt;

&lt;h2 id=&#34;free-m&#34;&gt;free -m&lt;/h2&gt;

&lt;p&gt;free命令用于展示系统内存的使用情况：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@c3e0fff4c337:/var/eshop/logs# free -m
             total       used       free     shared    buffers     cached
Mem:         16048       6919       9129         38          1       3522
-/+ buffers/cache:       3394      12654
Swap:         1905          0       1905
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要注意的是cache 的memory也应该算到free里面。&lt;/p&gt;

&lt;h2 id=&#34;sar-n-dev-1&#34;&gt;sar -n DEV 1&lt;/h2&gt;

&lt;p&gt;用于监控网卡的传输性能，确定是否带宽已经达到极限。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;03:18:51 PM     IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s   %ifutil
03:18:53 PM vethc4d02c4   2353.50   1888.00    643.56   2374.00      0.00      0.00      0.00      1.38
03:18:53 PM veth3cbedaf      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00
03:18:53 PM      eth0   4051.50   3223.50   3217.26    992.07      0.00      0.00      0.00      2.64
03:18:53 PM        lo      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00
03:18:53 PM   docker0   2353.50   1888.00    611.39   2374.00      0.00      0.00      0.00      0.00

03:18:53 PM     IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s   %ifutil
03:18:55 PM vethc4d02c4   1913.50   1504.00    598.69   1829.92      0.00      0.00      0.00      1.06
03:18:55 PM veth3cbedaf      0.50      0.50      0.03      0.04      0.00      0.00      0.00      0.00
03:18:55 PM      eth0   3386.00   2698.50   2738.93    946.30      0.00      0.00      0.00      2.24
03:18:55 PM        lo     48.00     48.00      2.34      2.34      0.00      0.00      0.00      0.00
03:18:55 PM   docker0   1914.00   1504.50    572.56   1829.95      0.00      0.00      0.00      0.00
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过rxkB/s和txkB/s可以得到网卡的负载情况。并可以确认是否已经超过带宽上限了。&lt;/p&gt;

&lt;h2 id=&#34;sar-n-tcp-etcp-1&#34;&gt;sar -n TCP,ETCP 1&lt;/h2&gt;

&lt;p&gt;sar是个比较复杂的命令，有多种使用方式，上面的信息也是基于这个命令。要获得TCP相关的统计信息这个命令就格外重要了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;06:38:32 PM  active/s passive/s    iseg/s    oseg/s
06:38:33 PM      0.00      0.00     11.64      9.59

06:38:32 PM  atmptf/s  estres/s retrans/s isegerr/s   orsts/s
06:38:33 PM      0.00      0.00      0.00      0.00      0.00

Average:     active/s passive/s    iseg/s    oseg/s
Average:         0.15      0.15     21.67     22.88

Average:     atmptf/s  estres/s retrans/s isegerr/s   orsts/s
Average:         0.00      0.05      0.00      0.00      0.25
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;active/s: 每秒钟发起的TCP链接数，例如通过connect()调用的方式；
passive/s：每秒钟远程发起的TCP链接数，例如通过accept()调用建立的链接。
retrans/s：每秒钟TCP重传的数量。这个如果过高的话说明网络状况较差。这个是比较粗略的统计。&lt;/p&gt;

&lt;h2 id=&#34;top&#34;&gt;top&lt;/h2&gt;

&lt;p&gt;top 命令是使用比较频繁的。内存、CPU、进程还有每个核的CPU使用情况都能一目了然。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;top - 18:58:23 up 256 days, 29 min,  4 users,  load average: 18.54, 42.49, 37.05
Tasks: 247 total,   7 running, 239 sleeping,   0 stopped,   1 zombie
%Cpu0  : 74.1 us,  4.7 sy,  0.0 ni, 20.9 id,  0.0 wa,  0.3 hi,  0.0 si,  0.0 st
%Cpu1  : 74.5 us,  4.6 sy,  0.0 ni, 20.2 id,  0.0 wa,  0.7 hi,  0.0 si,  0.0 st
%Cpu2  : 67.5 us,  7.0 sy,  0.0 ni, 16.6 id,  0.0 wa,  8.9 hi,  0.0 si,  0.0 st
%Cpu3  : 69.9 us,  4.0 sy,  0.0 ni, 25.5 id,  0.0 wa,  0.7 hi,  0.0 si,  0.0 st
%Cpu4  : 70.8 us,  4.7 sy,  0.0 ni, 23.9 id,  0.0 wa,  0.7 hi,  0.0 si,  0.0 st
%Cpu5  : 67.9 us,  4.3 sy,  0.0 ni, 27.2 id,  0.0 wa,  0.7 hi,  0.0 si,  0.0 st
%Cpu6  : 71.9 us,  5.0 sy,  0.0 ni, 22.5 id,  0.0 wa,  0.7 hi,  0.0 si,  0.0 st
%Cpu7  : 64.9 us,  4.6 sy,  0.0 ni, 29.8 id,  0.3 wa,  0.3 hi,  0.0 si,  0.0 st
KiB Mem:  16433764 total,  5466784 used, 10966980 free,     1820 buffers
KiB Swap:  1951740 total,        0 used,  1951740 free.  3726664 cached Mem

PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND                                                                                               
31418 www-data  20   0  500672  55144  31024 R  25.9  0.3   0:05.90 apache2                                                                                               
29182 www-data  20   0  500196  54780  31060 R  21.9  0.3   0:13.48 apache2                                                                                               
31450 www-data  20   0  499616  54304  30924 S  20.9  0.3   0:02.93 apache2                                                                                               
31384 www-data  20   0  498880  54072  31032 S  20.6  0.3   0:05.99 apache2                                                                                               
29066 www-data  20   0  498652  53944  31116 S  20.2  0.3   0:17.17 apache2                                                                                               
29267 www-data  20   0  493040  48260  31040 S  20.2  0.3   0:15.48 apache2                                                                                               
28780 www-data  20   0  498372  53604  31060 S  19.9  0.3   0:28.09 apache2               
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ctrl+S 能让其先停止更新，Ctrl+Q让其继续执行。&lt;/p&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;系统性能涉及很多的方面，遇到性能问题还是最好有个系统的方法，逐一解决每个问题。不然到了最后一团浆糊，还弄不清楚该优化那里。针对系统的性能优化需要一些经验的积累，慢慢就能轻车熟路，就像修车师父一样，老师父总能让人更放心些。
所以呢，这种事情不能急，还是慢慢来吧。多总结、多实践、多解决些问题，就会水到渠成了。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Apache Cache探究</title>
      <link>http://compasses.github.io/2015/12/09/apache-cache%E6%8E%A2%E7%A9%B6/</link>
      <pubDate>Wed, 09 Dec 2015 18:59:55 +0800</pubDate>
      <author>gnhe2009@gmail.com (Jet He)</author>
      <guid>http://compasses.github.io/2015/12/09/apache-cache%E6%8E%A2%E7%A9%B6/</guid>
      <description>

&lt;p&gt;Apache 作为一个hosting server，在2.2版本以上的也有较为强大的缓存功能。使其不管是作为web server还是代理server都能实现访问加速。
Apache支持两种cache模块，分别是mod_cache和mod_file_cache。mod_file_cache较为简单粗暴，cache那种不轻易改变的或者对实效性要求不高的文件较为适合，因为后台更新了缓存不能及时更新，需要一个周期或者重启Apache。
mod_cache是一种较为智能有效的、感知HTTP协议的cache方式，它有两种实现方案mod_mem_cache和mod_disk_cache，顾名思义mem是将响应内容缓存到内存中，disk是将响应内容缓存到磁盘中。mem是代价比较高的，因其缓存到内存中就会不可避免的导致Apache占用的系统内存增加。因此disk的缓存方案多被推荐使用。
具体详细的信息可以参考Apache的官方文档&lt;a href=&#34;http://httpd.apache.org/docs/2.2/caching.html#inmemory&#34;&gt;Caching Guide&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;浏览器刷新原则&#34;&gt;浏览器刷新原则&lt;/h2&gt;

&lt;p&gt;不同的请求header，cache的响应行为是不一样的，所以要搞清楚你的请求header是什么样的，响应header是什么样的，搞清楚才能较好的测试Apache的cache。
这里使用的测试浏览器是Firefox，也推荐使用Firefox，禁止Firefox的本地cache。
一般的请求头，类似点击页面链接：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Accept                 text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Encoding        gzip, deflate
Accept-Language        zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3
Connection             keep-alive
Cookie                 timeOffset=-480; timeOffset=-480; wp-settings-time-1=1445853102; PHPSESSID=ohiq63apsjmvsrl443778j22g6; ANW_TRACE_ID=25a6e917-0a0b-4580-a989-14ef71368ea1; CART_ITEMS=%5B%5D
Host                   10.128.163.72
User-Agent             Mozilla/5.0 (Windows NT 6.1; WOW64; rv:42.0) Gecko/20100101 Firefox/42.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;F5 刷新的请求头：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Accept                text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Encoding       gzip, deflate
Accept-Language       zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3
Cache-Control         max-age=0
Connection            keep-alive
Cookie                timeOffset=-480; timeOffset=-480; wp-settings-time-1=1445853102; PHPSESSID=ohiq63apsjmvsrl443778j22g6; ANW_TRACE_ID=25a6e917-0a0b-4580-a989-14ef71368ea1; CART_ITEMS=%5B%5D
Host                  10.128.163.72
User-Agent            Mozilla/5.0 (Windows NT 6.1; WOW64; rv:42.0) Gecko/20100101 Firefox/42.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意两者的变化，F5刷新时，请求头里面多了 Cache-Control 的域，max-age 赋值为0，这就告诉所有的后续服务器如果缓存了这个资源请尝试更新。不出意外后续的服务器会针对这个请求发 Conditional Requests，后台服务器验证资源的有效性，如果过期则返回200 ok，否则返回304 not modified。&lt;/p&gt;

&lt;p&gt;Ctrl + F5 刷新页面的请求头：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Accept                text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Encoding       gzip, deflate
Accept-Language       zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3
Cache-Control         no-cache
Connection            keep-alive
Cookie                timeOffset=-480; timeOffset=-480; wp-settings-time-1=1445853102; PHPSESSID=ohiq63apsjmvsrl443778j22g6; ANW_TRACE_ID=25a6e917-0a0b-4580-a989-14ef71368ea1; CART_ITEMS=%5B%5D
Host                  10.128.163.72
Pragma                no-cache
User-Agent            Mozilla/5.0 (Windows NT 6.1; WOW64; rv:42.0) Gecko/20100101 Firefox/42.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意这个请求头的新变化，又增加了一个新头域Pragma 值为 no-cache，Pragma 是HTTP1.0 里面定义的，Cache-Control 是HTTP1.1里面定义的，两个头域就足以保证了这个请求无法从cache中获取，直接强制性的去后台服务器发起获取。&lt;/p&gt;

&lt;p&gt;以上三种不同的请求头会使得cache服务器的有着完全不同的行为。&lt;/p&gt;

&lt;h2 id=&#34;实施apache缓存&#34;&gt;实施Apache缓存&lt;/h2&gt;

&lt;p&gt;因Apache官方也是推荐使用mod_cache+mod_disk_cache的方式，所以这里实施的也是这种方式。Apache默认这两个mod都是安装好的，直接起用就好了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo a2enmod cache
$ sudo a2enmod cache_disk
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;cache_disk的配置项：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;IfModule mod_cache.c&amp;gt;
&amp;lt;IfModule mod_cache_disk.c&amp;gt;
    CacheRoot /var/cache/apache2/mod_cache_disk
    # This will also cache local documents. It usually makes more sense to
    # put this into the configuration for just one virtual host.
    CacheEnable disk /wp-content/

    CacheDirLevels 2
    CacheDirLength 1

    CacheLock on
    CacheLockPath /tmp/mod_cache-lock
    CacheLockMaxAge 5

&amp;lt;/IfModule&amp;gt;
&amp;lt;/IfModule&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;CacheRoot 是cache文件的保存位置，需要注意的是CacheEnable后面的url，指定了要cache 的url路径，既是从域名的开始路径位置，上面的配置会缓存&lt;a href=&#34;http://xxxx/wp-content/&#34;&gt;http://xxxx/wp-content/&lt;/a&gt; 开始的请求。
CacheLock 配置是为了防止大量的资源刷新请求造成的&lt;a href=&#34;http://httpd.apache.org/docs/2.2/mod/mod_cache.html#thunderingherd&#34;&gt;资源“群涌”现象&lt;/a&gt;，避免对后台server造成严重的冲击。&lt;/p&gt;

&lt;p&gt;配置Apache的log level为debug，可以 对的cache 执行结果检查。&lt;/p&gt;

&lt;h2 id=&#34;cache效果检查&#34;&gt;cache效果检查&lt;/h2&gt;

&lt;p&gt;按照上述配置Apache后，重启Apache。访问静态资源，注意不是刷新或者强制刷新。查看Apache的error log。
例如能看到如下内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[Wed Dec 09 11:14:50.817537 2015] [cache:debug] [pid 10424] mod_cache.c(636): [client 10.128.161.107:56600] AH00763: cache: running CACHE_OUT filter
[Wed Dec 09 11:14:50.817543 2015] [cache:debug] [pid 10424] mod_cache.c(665): [client 10.128.161.107:56600] AH00764: cache: serving /wp-content/templates/halloween/assets/css/style.css
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;cache serving 表明该请求是从Apache缓存中返回的。浏览器中是否可以看到该请求是从Apache cache返回的呢，当然是可以的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Accept-Ranges          bytes
Age                    2379
Cache-Control          public, max-age=31104000
Connection             Keep-Alive
Content-Encoding       gzip
Content-Length         5901
Content-Type           text/css
Date                   Wed, 09 Dec 2015 09:22:39 GMT
Etag                   &amp;quot;7071-52671bdf81d18-gzip&amp;quot;
Keep-Alive             timeout=5, max=100
Last-Modified          Wed, 09 Dec 2015 07:07:23 GMTServerApache/2.4.7 (Ubuntu)
Vary                   Accept-Encoding
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看这个响应头里面的Age字段，如果不是从cache出去的话是没有这个Age字段的，Age的值是记录的这个资源当前的缓存时间，单位为秒，每次请求这个字段值都是会变化的。&lt;/p&gt;

&lt;h2 id=&#34;cache的资源副本&#34;&gt;cache的资源副本&lt;/h2&gt;

&lt;p&gt;Apache的cache根据响应头的Vary域来决定cache的资源被相应的client请求使用。HTTP头域中的Vary本来就是用来标识不同的客户端即不同的浏览器。
这个问题可以通过Firefox和chrome来验证，例如请求一个静态资源文件，都会带上&lt;code&gt;Accept-Encoding&lt;/code&gt;，响应头Vary域则是：&lt;code&gt;Vary: Accept-Encoding&lt;/code&gt;。
如果两个客户端的请求头里面的Accept-Encoding是不一样的，则cache服务会根据不同的Vary头选择相应的缓存内容。也就是说明具有不同Accept-Encode的客户端浏览器缓存的内容是不一样的。
也即相同的URL会有不同的缓存副本。&lt;/p&gt;

&lt;p&gt;当你看到不同的浏览器拿到的响应头里面的 Age 大小不一致时，就不用大惊小怪了，因为他们是不同的缓存副本。&lt;/p&gt;

&lt;h2 id=&#34;缓存资源的更新周期&#34;&gt;缓存资源的更新周期&lt;/h2&gt;

&lt;p&gt;使用Apache的缓存后，资源被缓存到disk上后，资源的更新首先由HTTP 的header字段决定，例如上面的响应头里面，那么这个资源的超时时间为max-age=31104000秒。
如果Cache-Control没有指定则会根据Last-Modified时间计算得出，具体如何计算可以参考&lt;a href=&#34;http://httpd.apache.org/docs/2.2/mod/mod_cache.html#cachelastmodifiedfactor&#34;&gt;官方文档&lt;/a&gt;。如果响应头里面也没有modify time，则会使用个默认的cache时间，当然这个可以&lt;a href=&#34;http://httpd.apache.org/docs/2.2/mod/mod_cache.html#cachemaxexpire&#34;&gt;自己配置任意时间&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;Apache只管缓存，缓存文件的清理需要借助一个deamon进程：htcacheclean。
下面命令表示每个60分钟，清理缓存一次，只清理过时的或最少使用的缓存，达到100M时也会清理缓存。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;htcacheclean –d60 -n -t -p/var/cache/apache2/mod_cache_disk -l100M –i
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是针对于那种需要及时更新的资源，需要另外的手段保证浏览器能够拿到最新的资源。&lt;a href=&#34;http://compasses.github.io/2015/11/27/http-cache/&#34;&gt;上一篇笔记里面的方法能较好&lt;/a&gt;的解决这个问题，&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>HTTP Cache</title>
      <link>http://compasses.github.io/2015/11/27/http-cache/</link>
      <pubDate>Fri, 27 Nov 2015 17:45:24 +0800</pubDate>
      <author>gnhe2009@gmail.com (Jet He)</author>
      <guid>http://compasses.github.io/2015/11/27/http-cache/</guid>
      <description>

&lt;p&gt;目前估计很少有网站不会使用http cache了，http cache 的合理使用能极大的提高用户体验，另一方面还能减轻server端的负担。特别现在流行https，使用好http cache也变得更加重要了。&lt;/p&gt;

&lt;h2 id=&#34;相关http-header字段&#34;&gt;相关HTTP header字段&lt;/h2&gt;

&lt;h3 id=&#34;last-modified和etag&#34;&gt;Last-Modified和ETag&lt;/h3&gt;

&lt;p&gt;两者的功能类似，一个是文件的最近一次的修改时间，一个是针对这个资源文件生成的tag。都是server端的返回。刷新页面时，请求头里面会带上If-Modified-Since或者 If-None-Match。
 但是Etag并&lt;a href=&#34;https://developer.yahoo.com/performance/rules.html#etags=&#34;&gt;不推荐使用&lt;/a&gt;，原因就是不同的server对Etag的生成算法可能不统一，特别在集群server的情况下。&lt;/p&gt;

&lt;h3 id=&#34;pragma&#34;&gt;Pragma&lt;/h3&gt;

&lt;p&gt;纯协议上的指令，对请求响应链路上的所有代理使用。例如如果pragma：no-chache，则请求在请求响应链上的任意节点都不会被缓存，因其于cache-control：no-chache意义一致。&lt;/p&gt;

&lt;h3 id=&#34;expires&#34;&gt;Expires&lt;/h3&gt;

&lt;p&gt;set response headers，对某个响应设置个超时时间，一般优先级不高，如果存在max-age的话，这个字段几乎不起作用。&lt;/p&gt;

&lt;h3 id=&#34;cache-control&#34;&gt;Cache-Control&lt;/h3&gt;

&lt;p&gt;public：标识验证后的respons可被缓存的。
no-store：任何情况下不缓存，并尽量不要保存到磁盘中。不缓存的资源并不能保证不被保存到磁盘中。例如浏览器的后退键，可能会导致看到过期的页面。
no-cache: 强制提交校验请求，严格模式，也即不缓存该响应。
must-revalidate: 缓存必须遵守任何的刷新规则，如果缓存超时必须重新发起请求，或者是条件请求。
proxy-revalidate： 和must 一样，只对proxy cache有效，对中间有cache server的情况，该字段指导cache server的验证方式和条件。
max-age: 指定刷新超时时间，即cache的超时时间。
s-maxage: 和 max-age一样，如果cache不是private的，他会指明cache servers使用这个s-maxage，针对public的cache有效，其会覆盖max-age。&lt;/p&gt;

&lt;h3 id=&#34;vary-https-www-fastly-com-blog-best-practices-for-using-the-vary-header&#34;&gt;&lt;a href=&#34;https://www.fastly.com/blog/best-practices-for-using-the-vary-header&#34;&gt;vary&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;通过vary告诉http cache，寻找缓存对象时需要考虑的头域字段。比如：浏览器发了两个request，一个带有accept-encoding， 一个没有。http 缓存的时候会带上这个vary标记，表示只有带有accept-encoding的缓存对象才能是使用。达到的效果就是request里面带有accept-encoding的请求，响应缓存只能被这样的请求获取。&lt;/p&gt;

&lt;p&gt;vary的不同会控制请求的发送数量。例如vary:*，表明每个request都是不同的。
简单的理解vary用来区分请求的差别，识别出不同的request。
vary的其他取值：user-agent, 让响应区分不同的agent；Referer, 区分这个request是从哪个页面而来。cookie, 不同认证信息不同的 request。vary指定的那些值就会影响浏览器的cache策略。&lt;/p&gt;

&lt;h2 id=&#34;需要注意的几个问题&#34;&gt;需要注意的几个问题&lt;/h2&gt;

&lt;h3 id=&#34;https-证书问题&#34;&gt;https 证书问题&lt;/h3&gt;

&lt;p&gt;如果是无效的证书，会导致缓存无法完全起用。本地测试是doc无法被cache，静态资源还是可以的。当然这跟浏览器的行为也有关系，Firefox里面添加例外证书变成合法的就可以正常缓存了。chrome的证书比较严格不好把红叉叉去掉。&lt;/p&gt;

&lt;h3 id=&#34;expires和max-age-优先级问题&#34;&gt;expires和max-age 优先级问题&lt;/h3&gt;

&lt;p&gt;当response头域里面两者都包含时，浏览器会优先选用max-age，当然这是我本地的测试结果。所有的情况可能难以覆盖，比如移动端的浏览器，其他的浏览器，除了Firefox、chrome、IE等等以外的。
另外就是expires是http1.0里面的，max-age在http1.1被引入，但是&lt;a href=&#34;https://www.mnot.net/blog/2007/05/15/expires_max-age&#34;&gt;这篇文章&lt;/a&gt;建议最好两者都带上正确的值，或者只带上max-age。&lt;/p&gt;

&lt;h3 id=&#34;conditional-requests&#34;&gt;Conditional Requests&lt;/h3&gt;

&lt;p&gt;条件请求是当浏览器发现资源超时时，如过了max-age或者expires date，会发起条件请求，如果server发现资源变化了会回复200 ok，否则回复304的status code。正确情况下资源cache后，浏览器是不会发条件请求的，直到资源超时后。当然也不排除某些浏览器会不停的发conditional request，更为详细的介绍，&lt;a href=&#34;https://greenbytes.de/tech/webdav/draft-ietf-httpbis-p4-conditional-20.html&#34;&gt;请看这里&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;静态资源缓存&#34;&gt;静态资源缓存&lt;/h2&gt;

&lt;p&gt;针对静态资源，更新时更加推荐使用变更文件名的方式，例如让文件名包含一个版本号的方式。这种比文件末尾增加query string更加有效，例如有些中间proxy就不会缓存带有查询字符的url。&lt;/p&gt;

&lt;h2 id=&#34;php配合apache-实现静态资源版本控制&#34;&gt;PHP配合apache 实现静态资源版本控制&lt;/h2&gt;

&lt;p&gt;针对静态资源的cache设置，这个&lt;a href=&#34;https://github.com/Compasses/server-configs-apache/tree/master/src/web_performance&#34;&gt;github&lt;/a&gt;有较好的配置模板做参考。基本上enmod headers即可。
针对静态文件php代码里面插入版本号，一般为时间戳或者数据库里面的更新时间：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    /*
     * change &amp;quot;assert/style.css&amp;quot; to &amp;quot;assert/style.xxxx.css&amp;quot;
     * if change failed just return the $src
     */
    public function assert_url_version_insert($src, $version) {
        $replacement = &#39;.&#39;.$version.&#39;.$1&#39;;
        $newpath = preg_replace(
            &#39;/\.(js|css)$/&#39;,
            $replacement,
            $src
        );
       
        return $newpath === NULL ? $src : $newpath;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还例如有的情况需要读取文件的修改时间作为时间戳：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ftime = filectime( $filePath);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面是通过读取文件的修改时间，也可以通过读取数据库的方式。
插入版本号：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if ($ftime) {
     $path = $this-&amp;gt;assert_url_version_insert($path, $ftime);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样页面加载的静态资源URL会变成：&lt;a href=&#34;http://xxxx.xx/js/xxx.版本号.css&#34;&gt;http://xxxx.xx/js/xxx.版本号.css&lt;/a&gt; 或者js。
Apache使能rewrite rule：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;RewriteRule ^(.+)\.(.+)\.(js|css)$ $1.$3 [L]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最好再使能headers模块，针对这类静态资源设置最大缓存时间：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;filesMatch &amp;quot;\.(css)$&amp;quot;&amp;gt;
        Header merge Cache-Control &amp;quot;public, max-age=31104000&amp;quot;
    &amp;lt;/filesMatch&amp;gt;
    &amp;lt;filesMatch &amp;quot;\.(js)$&amp;quot;&amp;gt;
        Header merge Cache-Control &amp;quot;public, max-age=31104000&amp;quot;
    &amp;lt;/filesMatch&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上述就完成了，只要后台修改了静态资源文件，则文件的名字会随着版本号的更新而更新，从而实现前端自动刷新缓存。否则这些资源文件会永远cache在客户端。超时时间为31104000s。&lt;/p&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;http cache 很复杂，牵扯较多的组件，上述只是针对Apache+PHP的方案实施。&lt;/li&gt;
&lt;li&gt;没有引入更加复杂的缓存中间件，其实目前有较多的组件可直接使用的。比如&lt;a href=&#34;https://www.varnish-cache.org/&#34;&gt;Varnish&lt;/a&gt;如果有机会使用的话，再进行研究。&lt;/li&gt;
&lt;li&gt;web 优化cache是比较重要的一环，当然还有其他的更多的零零碎碎的优化，还是需要建立在经验的基础上，多多思考这块就能不断提高了。&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>golang interface analysis by gdb</title>
      <link>http://compasses.github.io/2015/10/23/golang-interface-analysis-by-gdb/</link>
      <pubDate>Fri, 23 Oct 2015 22:45:07 +0800</pubDate>
      <author>gnhe2009@gmail.com (Jet He)</author>
      <guid>http://compasses.github.io/2015/10/23/golang-interface-analysis-by-gdb/</guid>
      <description>

&lt;p&gt;interface 在go语言中，是非常重要的一环，总有点让人感到很玄乎不定的感觉。官方的lib中有大量使用，似乎面向对象和动态绑定也能跟interface扯上关系。总之，如果能更好的理解interface的机理，就能更好的理解和使用Go了。&lt;/p&gt;

&lt;p&gt;interface的较为深层次的探讨在&lt;a href=&#34;http://research.swtch.com/interfaces&#34;&gt;这篇blog&lt;/a&gt;里面已经有较为详细的介绍。但是缺乏一些实践，本文遍结合此文，使用GDB实际研究一下。&lt;/p&gt;

&lt;h2 id=&#34;interface-内部存储&#34;&gt;interface 内部存储&lt;/h2&gt;

&lt;p&gt;interface的值，其实是两个指针的组合：data 和 tab。data 实际指向值的指针，tab是go runtime的一个struct：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// layout of Itab known to compilers
// allocated in non-garbage-collected memory
type itab struct {
    inter  *interfacetype

    _type  *_type

    link   *itab

    bad    int32
    unused int32
    fun    [1]uintptr // variable sized
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在运行时该结构会被runtime库计算出来，保证interface的正常运转。
使用&lt;strong&gt;go build -gcflags &amp;laquo;-N -l&amp;raquo;&lt;/strong&gt;编译便可以是用GDB来debug了。
断点断在最后一行代码，代码在最后列出。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) info locals
b = 200
s = {tab = 0x7ffff7e0f1c0, data = 0xc82000a3b0}
nothing = {_type = 0x4c1360, data = 0xc82000a430}
face = {tab = 0x0, data = 0x0}
any = {_type = 0x4e4a80, data = 0xc82000a3c0}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先看变量*s*，内部有个tab指针和data指针。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) p  *s.tab
$24 = {inter = 0x4dffa0, _type = 0x4e4a80, link = 0x0, bad = 0, unused = 0, fun = {4200784}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结构就是上面的itab的数据结构，其中的interfacetype 和 _type的结构分别为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type interfacetype struct {
    typ  _type

    mhdr []imethod

}
// Needs to be in sync with ../cmd/internal/ld/decodesym.go:/^func.commonsize,
// ../cmd/internal/gc/reflect.go:/^func.dcommontype and
// ../reflect/type.go:/^type.rtype.
type _type struct {
    size       uintptr
    ptrdata    uintptr // size of memory prefix holding all pointers
    hash       uint32
    _unused    uint8
    align      uint8
    fieldalign uint8
    kind       uint8
    alg        *typeAlg

    // gcdata stores the GC type data for the garbage collector.
    // If the KindGCProg bit is set in kind, gcdata is a GC program.
    // Otherwise it is a ptrmask bitmap. See mbitmap.go for details.
    gcdata  *byte
    _string *string
    x       *uncommontype

    ptrto   *_type

    zero    *byte // ptr to the zero value for this type
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;分别看下里面的内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) p  *s.tab.inter
$26 = {typ = {size = 16, ptrdata = 16, hash = 3958674519, _unused = 0 &#39;\000&#39;, align = 8 &#39;\b&#39;, fieldalign = 8 &#39;\b&#39;, kind = 20 &#39;\024&#39;, alg = 0x592770 &amp;lt;runtime.algarray+240&amp;gt;,
    gcdata = 0x537142 &amp;quot;\003\004\005\006\a\b\t\n\r\016\017\020\021\022\025\026\031\032\033\037,568&amp;gt;?Ur\236\237\325\365\377&amp;quot;, _string = 0x5161d0, x = 0x4e0018, ptrto = 0x4b6e80,
    zero = 0x539c40 &amp;lt;runtime.zerovalue&amp;gt; &amp;quot;&amp;quot;}, mhdr = {array = 0x4e0000, len = 1, cap = 1}}
(gdb) p  *s.tab._type
$27 = {size = 8, ptrdata = 0, hash = 1148337467, _unused = 0 &#39;\000&#39;, align = 8 &#39;\b&#39;, fieldalign = 8 &#39;\b&#39;, kind = 139 &#39;\213&#39;, alg = 0x5926d0 &amp;lt;runtime.algarray+80&amp;gt;,
  gcdata = 0x537140 &amp;quot;\001\002\003\004\005\006\a\b\t\n\r\016\017\020\021\022\025\026\031\032\033\037,568&amp;gt;?Ur\236\237\325\365\377&amp;quot;, _string = 0x5161c0, x = 0x4e4ac8, ptrto = 0x4e4d20,
  zero = 0x539c40 &amp;lt;runtime.zerovalue&amp;gt; &amp;quot;&amp;quot;}
(gdb) p  *s.tab.inter.typ._string
$28 = 0x50b930 &amp;quot;main.Stringer&amp;quot;
(gdb) p  *s.tab._type._string
$29 = 0x50b920 &amp;quot;main.Binary&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以清晰的看出，itab的type是interface所包含值的type信息：&lt;strong&gt;main.Binary&lt;/strong&gt;，而tab的interface type为该interface的类型信息: &lt;strong&gt;main.Stringer&lt;/strong&gt;。
他们的size是不一样的。Binary的size为8个字节，而interface是16个字节。
&lt;strong&gt;想想为啥interface是16个字节的大小？这里可以大胆猜测16个字节是系统内存管理的对齐对齐最小字节数，即libc之前的内存管理里面分配内存都是以16字节作为对齐的，这样也是为了方便内存管理吧。&lt;/strong&gt;
要想搞清楚tab里面所有变量的意义，那是不可能的了，在GDB调试过程中，发现中间穿插大量的汇编代码，特别是runtime库实现interface计算过程中。
继续，s的data也是个指针可以直接将其值打印出来：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) p *uint64(s.data)
$22 = 200
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为我们事先知道该值类型为64位的uint型。
接着看下any和nothing这两个变量。该两个变量有着不同的类型。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) p nothing
$51 = {_type = 0x4c1360, data = 0xc82000a430}
(gdb) p any
$52 = {_type = 0x4e4a80, data = 0xc82000a3c0}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;针对interface go的编译器有两种的内存优化策略，就像上面两个变量，他们就不再有itab了，只是type，原因是他们没有方法集。上面文章中说的第二种优化策略，在实际测试中并没有验证出来，即如果interface里面的data值是32位的，则该data字段会直接存该值，不会用指针多一层引用了，即代码中的s32。&lt;/p&gt;

&lt;p&gt;通过上面可以看出interface是runtime的产物，是go运行时的对象。这个很像C++中的虚函数表的行为。
从而也可以意识到interface是类型和接口同时兼备的，任何变量都可以赋值给interface，如果该变量是没有接口方法的话，那么interface就是只存其类型信息，否则如果有接口方法，就会多一个itab出来，里面会有其对应的函数列表。
&lt;strong&gt;这样也就很容易理解，interface可以包容任何变量了，因为在运行时，interface变量会记录其所包含值的类型信息。&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;interface使用&#34;&gt;interface使用&lt;/h2&gt;

&lt;p&gt;关于interface的使用方面，有不少文章做了介绍，比如：&lt;a href=&#34;http://jordanorelli.com/post/32665860244/how-to-use-interfaces-in-go&#34;&gt; How to use interfaces in Go&lt;/a&gt;和&lt;a href=&#34;https://golang.org/doc/effective_go.html#interfaces&#34;&gt;Effective Go&lt;/a&gt;。
从上面部分可以了解到，interface是一种运行时类型，既有函数集还有数据。interface本身定义只能定义方法集，你所要做的就是把这些方法赋予某个Object上面。这样Object就有了这个interface的能力，任意使用这个interface作为参数或者值的地方，Object也就可以畅通无阻了。
interface可以接纳任意类型，因interface内部的type信息是完备的：用type switch 可以获取interface内部value的类型信息，如下所示。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Stringer interface {
    String() string
}

var value interface{} // Value provided by caller.
switch str := value.(type) {
case string:
    return str
case Stringer:
    return str.String()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;interface 更为抽象化的接口，通过interface来定义你的行为方法，行为方法里面会对对象数据产生变化，这个也是需要进行隔离的。跟与C++编码那种面向对象的思想有点出入，看起来不是那么直观。面向对象即先定义对象，和对象的行为。Go里面也是可以定义自己的对象和方法，然后再把这些方法抽象成一个类型：interface，interface就可以使用在函数接口当中，其实此时传递的时候还是你所定义的对象。&lt;/p&gt;

&lt;p&gt;总体上感觉interface比面向对象更抽象了一层，需要在更多的实际开发过程中慢慢体会。&lt;/p&gt;

&lt;p&gt;附：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
     &amp;quot;fmt&amp;quot;
     &amp;quot;strconv&amp;quot;
)

type Stringer interface {
    String() string
}

func ToString(any interface{}) string {
    if v, ok := any.(Stringer); ok {
        return v.String()
    }
    switch v := any.(type) {
    case int:
        return strconv.Itoa(v)
    case float32:
        return strconv.FormatFloat(float64(v), &#39;g&#39;, -1, 32)
    }
    return &amp;quot;???&amp;quot;
}

type Binary uint64
type Binary32 uint32

func (i Binary) String() string {
    return strconv.FormatUint(i.Get(), 2)
}

func (i Binary) Get() uint64 {
    return uint64(i)
}

func (i Binary32) String() string {
    return strconv.FormatUint(uint64(i.Get()), 2)
}

func (i Binary32) Get() uint64 {
    return uint64(i)
}

func main() {
    
     b := Binary(200)
     b32 := Binary32(200)
    
     s := Stringer(b)
     s32 := Stringer(b32)
    
     any := (interface{})(b)
    
     fmt.Println(s.String())
     fmt.Println(s32.String())
    
     fmt.Println(ToString(any))
    
     var nothing interface{}

     nothing = uint64(200)
     fmt.Println(nothing)

     var face Stringer
    
     fmt.Println(face)
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>So Busy</title>
      <link>http://compasses.github.io/2015/08/05/so-busy/</link>
      <pubDate>Wed, 05 Aug 2015 20:45:07 +0800</pubDate>
      <author>gnhe2009@gmail.com (Jet He)</author>
      <guid>http://compasses.github.io/2015/08/05/so-busy/</guid>
      <description>&lt;p&gt;最近几周，有点回到华为的感觉了，没想到在大外企也有这么紧张的时候，但主要是部门管理完全掌握在国人手里。
整理下最近都是忙了点啥。
由于产品定位是个电商平台，那么前端theme的开发其实变得不是那么的重要了，重要的是后台能力的构建。也就是提供足够强大、灵活的接口供前端消费，这个重构的过程就是要满足这个定位了。
这其中有个恶心的地方就是本来平台开发是基于wordpress的，而wordpress本身是个开箱即用的东西，完全不是MVC的框架。但需要提供的接口要满足REST Ful 的。所以很多url 的route 规则需要自己去实现。这样下来发现如果最早使用一个PHP的MVC框架会省不小心啊。
好在这个过程需要研究下PHP的MVC框架，为后续的演进做好了铺垫。
另外一个项目就是需要开发自己的CMS系统，这个系统以OPEN API为基础。框架采用后端Java Spring， 前端使用angularJS。
由于对java确是使用的较少，什么java框架也没玩过，所以就聚焦在了angularJS上了。angularJS是前端的MVC框架，能力出众。值得深入研究使用。最起码javaScripts方面的知识派上用场了。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>前端经验</title>
      <link>http://compasses.github.io/2015/08/05/%E5%89%8D%E7%AB%AF%E7%BB%8F%E9%AA%8C/</link>
      <pubDate>Wed, 05 Aug 2015 20:45:07 +0800</pubDate>
      <author>gnhe2009@gmail.com (Jet He)</author>
      <guid>http://compasses.github.io/2015/08/05/%E5%89%8D%E7%AB%AF%E7%BB%8F%E9%AA%8C/</guid>
      <description>

&lt;p&gt;最近还是比较忙，blog好久没有写了，当然也不排除自己有点懈怠。也没有什么太多要写的，就是些工作上的事情。最近做前端比较多，还是就写写前端的一些经验吧。之前也说过，前端就是一个积累的过程，另外多借鉴一些成熟的前端框架会对自己的水平提高很有帮助。&lt;/p&gt;

&lt;h1 id=&#34;css相关&#34;&gt;CSS相关&lt;/h1&gt;

&lt;p&gt;因为开发是基于LESS的，所以代码相关的都是&lt;a href=&#34;http://less.bootcss.com/&#34;&gt;LESS&lt;/a&gt;的代码。
##mixin
可以看作是面向对象的CSS，直白的讲就是混合引入，也有翻译是混入或混合，这样感觉都是很模糊的。其实功能上就是定义一组属性、style在一个mixin中，可以让其他的class直接引用，作为公共的基础class。例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.ellipsis (@width) {
  width: @width;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个ellipsis class会将定宽文本进行截断，这样的class可能会在网站中多处使用，而且每次使用宽度可变，这样在使用时传入想要宽度的参数即可。例如产品名字的class：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;product-name {
     .ellipsis(8em);
     ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;media&#34;&gt;media&lt;/h2&gt;

&lt;p&gt;由于前端一直在使用&lt;a href=&#34;http://v3.bootcss.com/css/&#34;&gt;bootstrap&lt;/a&gt;，所以所有的responsive相关的design都是依赖bootstrap来实现。bootstrap的栅格系统需要一定的使用规则，有的时候过度使用会导致DOM结构过去复杂化了。例如其中的form，form里面必须按照一个input一个label的排列，如果想要添加一些文本信息或者增加其他的标签，又让他保持responsive，必须通过类似row下的col再嵌套row和col，这样就实现很复杂，让DOM结构看起来混乱不堪。
其实看看bootstrap.css里面的代码也不难发现，其实responsive的代码也不难写，问题是你不需要去写一个框架，框架的代码是普适的。你只是为了满足一个小特性，所以代码也会写的很精简。&lt;/p&gt;

&lt;p&gt;使用&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/CSS/@media&#34;&gt;media query&lt;/a&gt; 来索引屏幕尺寸并进行特定class的apply。可以让网页支持较好的自适应性。例如针对小屏幕某个class需要有些自适应的属性，下面这个css class在小屏幕上，屏幕宽度小于767px时，左侧增加20px的margin。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.class-name {
     @media(max-width: 767px) {
          margin-left: 20px;
          ...
     }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面是在class里面进行屏幕适应，更多的时候是定义整个class为自适应：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@media only screen and (max-width: 767px) {
     .class-name {
          ...
     }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;根据不同的尺寸class里面的style进行相应的变化。bootstrap也是这么玩的。
在移动设备上有横屏和竖屏的区分，也能做相应的自适应。
关键的属性：&lt;/p&gt;

&lt;p&gt;| media 属性     | 结果|
| &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;- |:&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-:|
| min-width      |  当任意浏览器宽度大于查询中定义的值时适用的规则。 |
| max-width      | 当任意浏览器宽度小于查询中定义的值时适用的规则。 |
| min-height | 当任意浏览器高度大于查询中定义的值时适用的规则。    |
| max-height | 当任意浏览器高度小于查询中定义的值时适用的规则。|
| orientation=portrait| 高度大于或等于宽度的任意浏览器适用的规则。相当于竖屏。|
| orientation=landscape| 宽度大于高度的任意浏览器适用的规则。相当于横屏。|&lt;/p&gt;

&lt;h2 id=&#34;语义化标签&#34;&gt;语义化标签&lt;/h2&gt;

&lt;p&gt;写一些复杂网页的时候，DOM元素的选取至关重要。要尽量结合Object的属性，进行语义上的对应选择，多使用语义化的标签。例如一个product detail页面，product属性是非常复杂的，有多个variant，variant下面有多个value。当选择variant和对应的value 的时候，就能确定一个单品，这时还会有多个事件的处理，例如每个单品的价格、库存都是变化的，产品的variant对应有相应的产品图片。
这样的DOM结构，全部使用div能做出来吗，肯定能做出来，但是复杂度就上去了。因为要兼顾前端UI的展示、JS的交互等等。通过观察多个电商网站的DOM结构，也能发现，大部分是使用：dl dt dd + ul li。即外层展示使用dl dt，dd里面套上ul + li 展示具体的variant value，这样的DOM结构清晰，CSS class的selector也很容易写，包括JS的也是一样的。&lt;/p&gt;

&lt;p&gt;上面只是简单举个实际过程中遇到的例子。其实语义化标签的使用包含很多其他的东西；随着经验的积累使用起来也会更加得心应手。&lt;/p&gt;

&lt;h1 id=&#34;js相关&#34;&gt;JS相关&lt;/h1&gt;

&lt;p&gt;JS遵从语言规范外，对单个页面使用的JS进行封装，让代码看起来不是太过去杂乱。如果前端的JS使用了框架应该不存在这样的问题。
封装的时候要对照页面的DOM结构和交互流程，让Object能更好为事件响应服务。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>PHP 框架之CodeIgniter &amp; Laravel</title>
      <link>http://compasses.github.io/2015/07/18/php-%E6%A1%86%E6%9E%B6%E4%B9%8Bcodeigniter--laravel/</link>
      <pubDate>Sat, 18 Jul 2015 18:45:07 +0800</pubDate>
      <author>gnhe2009@gmail.com (Jet He)</author>
      <guid>http://compasses.github.io/2015/07/18/php-%E6%A1%86%E6%9E%B6%E4%B9%8Bcodeigniter--laravel/</guid>
      <description>

&lt;h1 id=&#34;说明&#34;&gt;说明&lt;/h1&gt;

&lt;p&gt;最近产品考虑更换前端框架，重点考察了CodeIgniter 和 Laravel两个框架，现对其进行下对比分析。&lt;/p&gt;

&lt;h1 id=&#34;总体对比&#34;&gt;总体对比&lt;/h1&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;CodeIgniter&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Laravel&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Document&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Good enough&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Good enough&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Performance&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;差不多 3倍于 Laravel&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;MVC&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Good enough&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Good enough&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;TWIG&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;自己添加 TWIG lib&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;使用三方插件&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;third-party&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;自己添加，放到指定目录&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;composer managment&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Route&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;default mapping ：&amp;raquo;example.com/class/function/id/&amp;raquo; can be remap, more code than Laravel&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Simple and clear&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;summary&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;简单 精巧&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;易用，更为丰满&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;CodeIgniter 基本上是个MVC的空架子，代码量极小，开发的花基本上 100%的掌控在自己手里。 Laravel还是加载了不少的三方 component，比CodeIgniter 庞大些。
对MVC的支持都很清晰，URL的路由也很简单易扩展。&lt;/p&gt;

&lt;h1 id=&#34;测试环境&#34;&gt;测试环境：&lt;/h1&gt;

&lt;p&gt;主要是使用了Laravel 的HomeStead环境，通过virtual box + vagrant标准用法，加载Laravel的框架代码；要使其加载CodeIgniter框架，需要修改Nginx的配置，增加新的server，只要端口号换成新的，root指定到CodeIgniter的跟目录即可。
总体上是Nginx+php5-fpm+mysql+ Ubuntu + CodeIgniter 源码包 + Laravel 源码包。源码包共享在本机上。&lt;/p&gt;

&lt;h1 id=&#34;测试页面&#34;&gt;测试页面：&lt;/h1&gt;

&lt;p&gt;Modal：使用product数据，获取某个product上的所有信息。
View：引入Twig模板引擎，创建几个twig模板，在controller层render。
Controller：调用modal获取数据，使用 twig render 页面。&lt;/p&gt;

&lt;p&gt;这两个框架都用非常清晰的 MVC结构，上述页面的代码几乎可以在两者之间无缝迁移。&lt;/p&gt;

&lt;h1 id=&#34;性能对比测试&#34;&gt;性能对比测试：&lt;/h1&gt;

&lt;p&gt;针对这个页面进行性能测试：页面大小为 8KB， 加载一个已有的CSS文件大小为 87.7KB。
使用Apache的ab test进行测试：
AB test:
ab -n 1000 -c 80 &lt;a href=&#34;http://192.168.10.10:8080/productdetail/&#34;&gt;http://192.168.10.10:8080/productdetail/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;laravel-结果&#34;&gt;Laravel 结果:&lt;/h2&gt;

&lt;p&gt;Server Software:        nginx/1.8.0
Server Hostname:        192.168.10.10
Server Port:            80&lt;/p&gt;

&lt;p&gt;Document Path:          /product/
Document Length:        200205 bytes&lt;/p&gt;

&lt;p&gt;Concurrency Level:      80
Time taken for tests:   112.455 seconds
Complete requests:      1000
Failed requests:        0
Total transferred:      200793036 bytes
HTML transferred:       200205000 bytes
Requests per second:    8.89 &lt;a href=&#34;mean&#34;&gt;#/sec&lt;/a&gt;
Time per request:       8996.416 &lt;a href=&#34;mean&#34;&gt;ms&lt;/a&gt;
Time per request:       112.455 &lt;a href=&#34;mean, across all concurrent requests&#34;&gt;ms&lt;/a&gt;
Transfer rate:          1743.69 [Kbytes/sec] received&lt;/p&gt;

&lt;p&gt;Connection Times (ms)&lt;/p&gt;

&lt;p&gt;min  mean[+/-sd] median   max
Connect:        0    1   1.0      0      18
Processing:  2001 8604 1574.3   8488   17271
Waiting:     1999 8594 1572.4   8480   17269
Total:       2005 8604 1574.0   8490   17271
WARNING: The median and mean for the initial connection time are not within a normal deviation&lt;/p&gt;

&lt;p&gt;These results are probably not that reliable.&lt;/p&gt;

&lt;p&gt;Percentage of the requests served within a certain time (ms)&lt;/p&gt;

&lt;p&gt;50%   8490&lt;/p&gt;

&lt;p&gt;66%   8695&lt;/p&gt;

&lt;p&gt;75%   8960&lt;/p&gt;

&lt;p&gt;80%   9098&lt;/p&gt;

&lt;p&gt;90%   9951&lt;/p&gt;

&lt;p&gt;95%  12074&lt;/p&gt;

&lt;p&gt;98%  12548&lt;/p&gt;

&lt;p&gt;99%  12944&lt;/p&gt;

&lt;p&gt;100%  17271 (longest request)&lt;/p&gt;

&lt;h2 id=&#34;codeigniter-结果&#34;&gt;CodeIgniter 结果:&lt;/h2&gt;

&lt;p&gt;Server Software:        nginx/1.8.0
Server Hostname:        192.168.10.10
Server Port:            8080&lt;/p&gt;

&lt;p&gt;Document Path:          /productdetail/
Document Length:        200205 bytes&lt;/p&gt;

&lt;p&gt;Concurrency Level:      80
Time taken for tests:   40.332 seconds
Complete requests:      1000
Failed requests:        0
Total transferred:      200341000 bytes
HTML transferred:       200205000 bytes
Requests per second:    24.79 &lt;a href=&#34;mean&#34;&gt;#/sec&lt;/a&gt;
Time per request:       3226.569 &lt;a href=&#34;mean&#34;&gt;ms&lt;/a&gt;
Time per request:       40.332 &lt;a href=&#34;mean, across all concurrent requests&#34;&gt;ms&lt;/a&gt;
Transfer rate:          4850.86 [Kbytes/sec] received&lt;/p&gt;

&lt;p&gt;Connection Times (ms)&lt;/p&gt;

&lt;p&gt;min  mean[+/-sd] median   max
Connect:        0    1   1.3      0      23
Processing:   346 3097 456.3   3169    3649
Waiting:      343 3089 455.7   3161    3645
Total:        351 3098 455.5   3170    3649&lt;/p&gt;

&lt;p&gt;Percentage of the requests served within a certain time (ms)&lt;/p&gt;

&lt;p&gt;50%   3170&lt;/p&gt;

&lt;p&gt;66%   3216&lt;/p&gt;

&lt;p&gt;75%   3250&lt;/p&gt;

&lt;p&gt;80%   3270&lt;/p&gt;

&lt;p&gt;90%   3326&lt;/p&gt;

&lt;p&gt;95%   3467&lt;/p&gt;

&lt;p&gt;98%   3551&lt;/p&gt;

&lt;p&gt;99%   3582&lt;/p&gt;

&lt;p&gt;100%   3649 (longest request)&lt;/p&gt;

&lt;h1 id=&#34;总结&#34;&gt;总结&lt;/h1&gt;

&lt;p&gt;CodeIgniter 更轻便，代码可以做到100%掌控；Laravel相比CodeIgniter更加丰满些，使用composer管理扩展性增强了不少。
如果选择从头开始的话，感觉CodeIgniter更好些。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Go Go</title>
      <link>http://compasses.github.io/2015/07/09/go-go/</link>
      <pubDate>Thu, 09 Jul 2015 17:45:07 +0800</pubDate>
      <author>gnhe2009@gmail.com (Jet He)</author>
      <guid>http://compasses.github.io/2015/07/09/go-go/</guid>
      <description>&lt;p&gt;最近在学习Go语言。认识Go语言是个偶然，首选是Docker容器的使用，Docker的兴起目前可谓风生水起，应用部署和各种云平台都在推行。其使用Go语言开发，之前没有听说过的。断断续续的找相关的博客、资料进行了解。发现Go 是有很多吸引人的地方，自己非常感兴趣，最近买的一本《Go Web编程》今天到手了。&lt;/p&gt;

&lt;p&gt;也说下自己的缘由，很多人都说Go 很容易上手，这应该对C系的开发人员而说的，Go语言的发明者也是C语言的作者，Go语言本身很多的语法、类型、结构等用法类似于C语言，如果编译运行的话二进制文件都能用GDB进行调试。Go语言是个集大成者，在里面你能看到或者重新认识一些语言特性，它有诸多动态语言特有的特性。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;首选想说的就是函数闭包，闭包函数在JavaScript里面应用的最广泛，用于各种回调处理、变量的scope控制等，在Go语言里面也有，使用起来几乎没有什么差别，也能当成变量传递等等。&lt;/li&gt;
&lt;li&gt;内置强大的数据结构，例如slice、map，开发的快捷易用性可以和Python媲美。slice 类似于Python、PHP里面的array，map也和Python里面的字典。&lt;/li&gt;
&lt;li&gt;interface的类型使用，interface让Go有了面向对象的能力，interface是非常有魔力的东西，应该会是非常广泛的，把面向对象的能力放大了。Go里面的反射功能也是依赖于interface，这篇文章&lt;a href=&#34;http://research.swtch.com/interfaces&#34;&gt;Go Data Structures: Interfaces&lt;/a&gt;有较深入的讲解。&lt;/li&gt;
&lt;li&gt;并发编程的支持，可以写并发执行的代码，通过go关键字来完成。goroutine确是是个好东西，用户层上的并发协程，能有效的利用多核计算能力。Go能原生的支持并发编程并能很好的利用多核能力是个极大的优势。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;有人说不能把Go作为偏向Web的语言，这应该是比较片面的。就像Python一样，一直都是当成工具使用，能快速的开发一些小工具，而现在呢，Python的Web框架为Python的流行应该是起了主要作用。Go的使用应该要偏向云平台开发、Web开发，高性能、高并发的场景。试想下Docker的流行，国内七牛公司对Go语言的推崇。&lt;/p&gt;

&lt;p&gt;Go相对于PHP、JAVA年轻很多，但自己相信它会成为后起之秀，也做好了这个准备。&lt;/p&gt;

&lt;p&gt;很高兴开启Go语言之旅。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>WEB 开发点滴</title>
      <link>http://compasses.github.io/2015/07/07/web-%E5%BC%80%E5%8F%91%E7%82%B9%E6%BB%B4/</link>
      <pubDate>Tue, 07 Jul 2015 20:45:07 +0800</pubDate>
      <author>gnhe2009@gmail.com (Jet He)</author>
      <guid>http://compasses.github.io/2015/07/07/web-%E5%BC%80%E5%8F%91%E7%82%B9%E6%BB%B4/</guid>
      <description>

&lt;p&gt;WEB开发错综复杂，很多知识点让你抓不到重点，用过了忘记了，下次用还要重头开始。例如CSS，很多class，很多的取值，每个都有很多视觉效果。拿到UX的design，不同的人做出来的效果可以保持一致，但是对应的CSS和JS可能完全不一样。正是这种WEB开发的灵活性，更让人抓不到重点。&lt;/p&gt;

&lt;p&gt;最近又在做一些UI的开发工作，集中在前端，需要CSS和JS，事情做完了，仔细想想里面用到的CSS class都理解了吗？发现并没用。如此众多，如何才能掌握这些class呢？突然想到CSS class虽然众多但是用到的不是全集，所以在学习上也要化整为零，化繁为简，各个击破。这次就好好记录下CSS中的overflow和position类。&lt;/p&gt;

&lt;h1 id=&#34;position&#34;&gt;POSITION&lt;/h1&gt;

&lt;p&gt;解释说明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;position
    
&#39;position&#39;
Value:  
static | relative | absolute | fixed | inherit
Initial:  
static
Applies to:  
all elements
Inherited:  
no
Percentages:  
N/A
Media:  
visual
Computed value:  
as specified
The values of this property have the following meanings:
static
The box is a normal box, laid out according to the normal flow. The &#39;top&#39;, &#39;right&#39;, &#39;bottom&#39;, and &#39;left&#39; properties do not apply.
relative
The box&#39;s position is calculated according to the normal flow (this is called the position in normal flow). Then the box is offset relative to its normal position. When a box B is relatively positioned, the position of the following box is calculated as though B were not offset. The effect of &#39;position:relative&#39; on table-row-group, table-header-group, table-footer-group, table-row, table-column-group, table-column, table-cell, and table-caption elements is undefined.
absolute
The box&#39;s position (and possibly size) is specified with the &#39;top&#39;, &#39;right&#39;, &#39;bottom&#39;, and &#39;left&#39; properties. These properties specify offsets with respect to the box&#39;s containing block. Absolutely positioned boxes are taken out of the normal flow. This means they have no impact on the layout of later siblings. Also, though absolutely positioned boxes have margins, they do not collapse with any other margins.
fixed
The box&#39;s position is calculated according to the &#39;absolute&#39; model, but in addition, the box is fixed with respect to some reference. As with the &#39;absolute&#39; model, the box&#39;s margins do not collapse with any other margins. In the case of handheld, projection, screen, tty, and tv media types, the box is fixed with respect to the viewport and doesn&#39;t move when scrolled. In the case of the print media type, the box is rendered on every page, and is fixed with respect to the page box, even if the page is seen through a viewport (in the case of a print-preview, for example). For other media types, the presentation is undefined. Authors may wish to specify &#39;fixed&#39; in a media-dependent way. For instance, an author may want a box to remain at the top of the viewport on the screen, but not at the top of each printed page. The two specifications may be separated by using an @media rule, as in:
Example(s):
  
@media screen {
  h1#first { position: fixed }
}
@media print {
  h1#first { position: static }
}
UAs must not paginate the content of fixed boxes. Note that UAs may print invisible content in other ways. See &amp;quot;Content outside the page box&amp;quot; in chapter 13.
User agents may treat position as &#39;static&#39; on the root element.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;元素的位置定位影响它的视觉模型，例如：p, h1, div 为块级元素，块级元素在展示的时候是以垂直摆放的，元素之间的垂直距离由垂直间隔决定，即margin。又如：strong、span为inline elements，内联元素。展示为水平摆放，这种元素改变视觉效果只能通过line height、或者水平 border 、padding、margin。&lt;/p&gt;

&lt;h2 id=&#34;relative-position&#34;&gt;relative position&lt;/h2&gt;

&lt;p&gt;相对定位比较简单，就是可以通过属性 top、left、bottom、right来改变它的位置，改变是相对于它的原始位置开始计算的。它于正常的文档流定位类似。跟position的另一个取值static一样，如果不改变它的位置属性值。&lt;/p&gt;

&lt;h2 id=&#34;absolute-position&#34;&gt;absolute position&lt;/h2&gt;

&lt;p&gt;类似于relative position，absolute position是相对于其最近的父节点而摆放。如果没有最近的父节点，就绑定在body元素上。absolute position让其父节点必须是relative position。&lt;/p&gt;

&lt;h2 id=&#34;fixed-position&#34;&gt;fixed position&lt;/h2&gt;

&lt;p&gt;是absolute position的子类，不同的是它的视口是整个window， 利用它就可以固定一个元素在这个窗口视图上，无论怎么滚动这个元素会固定在这个窗口中。&lt;/p&gt;

&lt;h2 id=&#34;floating&#34;&gt;floating&lt;/h2&gt;

&lt;p&gt;floatting也是重要的布局类，经常需要将一个元素靠左或者靠右对齐。靠左或者靠右直到它的外边缘与父节点边缘接壤，或者其他float元素的边缘。float元素并不在正常的文档流中。即只要元素变为float元素了，其所在的body就会将其视为不存在了。在实现那些文字环绕的效果时，都会使用到这个class，因为float元素会脱离正常的文档流，所以在制作这种效果的时候需要用clear配合使用。&lt;/p&gt;

&lt;h1 id=&#34;overflow&#34;&gt;overflow&lt;/h1&gt;

&lt;p&gt;解释：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;overflow
    
&#39;overflow&#39;
Value:  
visible | hidden | scroll | auto | inherit
Initial:  
visible
Applies to:  
non-replaced block-level elements, table cells, and inline-block elements
Inherited:  
no
Percentages:  
N/A
Media:  
visual
Computed value:  
as specified
This property specifies whether content of a block-level element is clipped when it overflows the element&#39;s box. It affects the clipping of all of the element&#39;s content except any descendant elements (and their respective content and descendants) whose containing block is the viewport or an ancestor of the element. Values have the following meanings:
visible
This value indicates that content is not clipped, i.e., it may be rendered outside the block box.
hidden
This value indicates that the content is clipped and that no scrolling user interface should be provided to view the content outside the clipping region.
scroll
This value indicates that the content is clipped and that if the user agent uses a scrolling mechanism that is visible on the screen (such as a scroll bar or a panner), that mechanism should be displayed for a box whether or not any of its content is clipped. This avoids any problem with scrollbars appearing and disappearing in a dynamic environment. When this value is specified and the target medium is &#39;print&#39;, overflowing content may be printed.
auto
The behavior of the &#39;auto&#39; value is user agent-dependent, but should cause a scrolling mechanism to be provided for overflowing boxes.
Even if &#39;overflow&#39; is set to &#39;visible&#39;, content may be clipped to a UA&#39;s document window by the native operating environment.
UAs must apply the &#39;overflow&#39; property set on the root element to the viewport. HTML UAs must instead apply the &#39;overflow&#39; property from the BODY element to the viewport, if the value on the HTML element is &#39;visible&#39;. The &#39;visible&#39; value when used for the viewport must be interpreted as &#39;auto&#39;. The element from which the value is propagated must have a used value for &#39;overflow&#39; of &#39;visible&#39;.
In the case of a scrollbar being placed on an edge of the element&#39;s box, it should be inserted between the inner border edge and the outer padding edge. The space taken up by the scrollbars affects the computation of the dimensions in the rendering model.
Example(s):
Consider the following example of a block quotation (&amp;lt;blockquote&amp;gt;) that is too big for its containing block (established by a &amp;lt;div&amp;gt;). Here is the source:
&amp;lt;div&amp;gt;
&amp;lt;blockquote&amp;gt;
&amp;lt;p&amp;gt;I didn&#39;t like the play, but then I saw
it under adverse conditions - the curtain was up.&amp;lt;/p&amp;gt;
&amp;lt;cite&amp;gt;- Groucho Marx&amp;lt;/cite&amp;gt;
&amp;lt;/blockquote&amp;gt;
&amp;lt;/div&amp;gt;
Here is the style sheet controlling the sizes and style of the generated boxes:
div { width : 100px; height: 100px;
      border: thin solid red;
      }

blockquote   { width : 125px; height : 100px;
      margin-top: 50px; margin-left: 50px;
      border: thin dashed black
      }

cite { display: block;
       text-align : right;
       border: none
       }
The initial value of &#39;overflow&#39; is &#39;visible&#39;, so the &amp;lt;blockquote&amp;gt; would be formatted without clipping, something like this:
   [D]
Setting &#39;overflow&#39; to &#39;hidden&#39; for the &amp;lt;div&amp;gt;, on the other hand, causes the &amp;lt;blockquote&amp;gt; to be clipped by the containing block:
   [D]
A value of &#39;scroll&#39; would tell UAs that support a visible scrolling mechanism to display one so that users could access the clipped content.
Finally, consider this case where an absolutely positioned element is mixed with an overflow parent.
Style sheet:
  container { position: relative; border: solid; }
  scroller { overflow: scroll; height: 5em; margin: 5em; }
  satellite { position: absolute; top: 0; }
  body { height: 10em; }
Document fragment:
  &amp;lt;container&amp;gt;
   &amp;lt;scroller&amp;gt;
    &amp;lt;satellite/&amp;gt;
    &amp;lt;body/&amp;gt;
   &amp;lt;/scroller&amp;gt;
  &amp;lt;/container&amp;gt;
In this example, the &amp;quot;scroller&amp;quot; element will not scroll the &amp;quot;satellite&amp;quot; element, because the latter&#39;s containing block is outside the element whose overflow is being clipped and scrolled.
11.1. The ‘overflow’, ‘overflow-x’ and ‘overflow-y’ properties
In the preceding sections, several things (such as flow roots) depend on the value of ‘overflow’. We probably need to rewrite them in terms of “overflow-x and/or -y” or similar.
Name:
overflow-x, overflow-y,
Value:
visible | hidden | scroll | auto | no-display | no-content
Initial:
visible
Applies to:
non-replaced block-level elements and non-replaced ‘inline-block’ elements
Inherited:
no
Percentages:
N/A
Media:
visual
Computed value:
as specified, except ‘visible’, see text
Name:
overflow
Value:
[ visible | hidden | scroll | auto | no-display | no-content ]{1,2}
Initial:
see individual properties
Applies to:
non-replaced block-level elements and non-replaced ‘inline-block’ elements
Inherited:
no
Percentages:
N/A
Media:
visual
Computed value:
as specified, except ‘visible’, see text
These properties specify whether content is clipped when it overflows the element&#39;s content area. It affects the clipping of all of the element&#39;s content except any descendant elements (and their respective content and descendants) whose containing block is the viewport or an ancestor of the element. ‘Overflow-x’ determines clipping at the left and right edges, ‘overflow-y’ at the top and bottom edges.
‘Overflow’ is a shorthand. If it has one keyword, it sets both ‘overflow-x’ and ‘overflow-y’ to that keyword; if it has two, it sets ‘overflow-x’ to the first and ‘overflow-y’ to the second. Keywords have the following meanings:
visible
This value indicates that content is not clipped, i.e., it may be rendered outside the content box.
hidden
This value indicates that the content is clipped and that no scrolling mechanism should be provided to view the content outside the clipping region.
scroll
This value indicates that the content is clipped and that if the user agent uses a scrolling mechanism that is visible on the screen (such as a scroll bar or a panner), that mechanism should be displayed for a box whether or not any of its content is clipped. This avoids any problem with scrollbars appearing and disappearing in a dynamic environment. When this value is specified and the target medium is ‘print’, overflowing content may be printed.
auto
The behavior of the ‘auto’ value is UA-dependent, but should cause a scrolling mechanism to be provided for overflowing boxes.
no-display
When the content doesn&#39;t fit in the content box, the whole box is removed, as if ‘display: none’ were specified. [This idea is due to Till Halbach &amp;lt;tillh@opera.com&amp;gt;, July 21, 2005]
no-content
When the content doesn&#39;t fit in the content box, the whole content is hidden, as if ‘visibility: hidden’ were specified. [This idea is due to Till Halbach &amp;lt;tillh@opera.com&amp;gt;, July 21, 2005]
Even if ‘overflow’ is set to ‘visible’, content may be clipped to a UA&#39;s document window by the native operating environment.
UAs must apply the ‘overflow’ property set on the root element to the viewport. HTML UAs must instead apply the ‘overflow’ property from the BODY element to the viewport, if the value on the HTML element is ‘visible’. The ‘visible’ value when used for the viewport must be interpreted as ‘auto’. The element from which the value is propagated must have a used value for ‘overflow’ of ‘visible’.
The para above is from CSS 2.1. Need to check if the introduction of overflow-x/y changes anything.
In the case of a scrollbar being placed on an edge of the element&#39;s box, it should be inserted between the inner border edge and the outer padding edge. The space taken up by the scrollbars affects the computation of the dimensions in the rendering model.
A UA may use multiple scrolling mechanisms at the same time. E.g., if content overflows both to the right and to the bottom, it may use a marquee effect for the overflow to the right and a scrollbar for the overflow to the bottom.
Note that a box with ‘overflow’ other than ‘visible’ is a flow root.
Consider the following example of a block quotation (&amp;lt;blockquote&amp;gt;) that is too big for its containing block (established by a &amp;lt;div&amp;gt;). Here is the source:
&amp;lt;div&amp;gt;
&amp;lt;blockquote&amp;gt;
&amp;lt;p&amp;gt;I didn&#39;t like the play, but then I saw
it under adverse conditions - the curtain was up.&amp;lt;/p&amp;gt;
&amp;lt;cite&amp;gt;- Groucho Marx&amp;lt;/cite&amp;gt;
&amp;lt;/blockquote&amp;gt;
&amp;lt;/div&amp;gt;
Here is the style sheet controlling the sizes and style of the generated boxes:
div { width : 100px; height: 100px;
      border: thin solid red;
      }

blockquote   { width : 125px; height : 100px;
      margin-top: 50px; margin-left: 50px;
      border: thin dashed black
      }

cite { display: block;
       text-align : right;
       border: none
       }
The initial value of ‘overflow’ is ‘visible’, so the &amp;lt;blockquote&amp;gt; would be formatted without clipping, something like this:

Possible rendering with ‘overflow: visible’
Setting ‘overflow’ to ‘hidden’ for the &amp;lt;div&amp;gt;, on the other hand, causes the &amp;lt;blockquote&amp;gt; to be clipped by the containing block:

Possible rendering with ‘overflow: hidden’
A value of ‘scroll’ would tell UAs that support a visible scrolling mechanism to display one so that users could access the clipped content.
Consider this case where an absolutely positioned element is mixed with an overflow parent. Style sheet:
container { position: relative; border: solid; }
scroller { overflow: scroll; height: 5em; margin: 5em; }
satellite { position: absolute; top: 0; }
body { height: 10em; }
Document fragment:
&amp;lt;container&amp;gt;
&amp;lt;scroller&amp;gt;
  &amp;lt;satellite/&amp;gt;
  &amp;lt;body/&amp;gt;
&amp;lt;/scroller&amp;gt;
&amp;lt;/container&amp;gt;
In this example, the “scroller” element will not scroll the “satellite” element, because the latter&#39;s containing block is outside the element whose overflow is being clipped and scrolled.
The combination of collapsing margins, ‘max-height’ and ‘overflow: auto’ can lead to subtle differences in implementations, unless special care is taken. A UA should assume that an element can be rendered without a scrolling mechanism first, perform all the collapsing of margins, and check that the content height is indeed less than the ‘max-height’. If it is not, the process is repeated under the assumption that a scrolling mechanism is needed.
In the following document fragment, the outer DIV has ‘height: auto’, but ‘max-height: 5em’. The inner DIV has large margins and would normally just fit:
...
    #d1 { overflow: auto; max-height: 5em }
    #d2 { margin: 2em; line-height: 1 }
...
&amp;lt;div id=d1&amp;gt;
  &amp;lt;div id=d2&amp;gt;
    This DIV has big margins.
  &amp;lt;/DIV&amp;gt;
&amp;lt;/DIV&amp;gt;
If we assume that d1 needs scroll bars, then the height of d1, including the single line of text and twice 2em of margins, adds up to 5em plus a scrollbar. Since that is greater than 5em, the maximum allowed height, it seems we made the right assumption and d1 indeed needs scrollbars.
However, we should have started by assuming that no scrollbars are needed. In that case the content height of d1 is exactly the maximum height of 5em, proving that the assumption was correct and d1 indeed should not have scrollbars.
The computed values of ‘overflow-x’ and ‘overflow-y’ are the same as their specified values, except that some combinations with ‘visible’ are not possible: if one is specified as ‘visible’ and the other is ‘scroll’ or ‘auto’, then ‘visible’ is set to ‘auto’. The computed value of ‘overflow’ is equal to the computed value of ‘overflow-x’ if ‘overflow-y’ is the same; otherwise it is the pair of computed values of ‘overflow-x’ and ‘overflow-y’.
The scrolling mechanism depends on the UA. The most common mechanism is a scrollbar, but panners, hand cursors, page flickers, etc. are also possible. A value of ‘scroll’ would tell UAs that support a visible scrolling mechanism to display one so that users can access the clipped content. The ‘overflow-style’ property lets an author specify one or more preferred scrolling mechanism.
Note that ‘overflow-x’ and ‘overflow-y’ did not exist in CSS2.
Note that ‘text-overflow’ (see [CSS3TEXT] ) can be used to give a visual indication where text has been clipped.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;overflow，常与定高的元素配合使用，如果元素定高，通过overflow-y: auto, 如果内容高度大于定高元素就会出现滚动条。如果定高元素内部需要出现overflow：visiable的元素，需要重新更改overflow的属性值。因为默认元素的overflow是继承父节点的。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Nginx &#43; Docker Cluster &amp; session sticky</title>
      <link>http://compasses.github.io/2015/07/06/nginx--docker-cluster--session-sticky/</link>
      <pubDate>Mon, 06 Jul 2015 17:45:07 +0800</pubDate>
      <author>gnhe2009@gmail.com (Jet He)</author>
      <guid>http://compasses.github.io/2015/07/06/nginx--docker-cluster--session-sticky/</guid>
      <description>

&lt;h2 id=&#34;基本配置&#34;&gt;基本配置&lt;/h2&gt;

&lt;p&gt;本地开发环境和生产环境还是有很大的区分，最近性能测试发现结果很不好，于是想自己去搭建一个类似生产环境的性能测试环境。&lt;/p&gt;

&lt;p&gt;由于前期已经有了docker的开发环境，这里只需要增加Nginx 作为反向代理。
在/etc/nginx/conf.d目录下新建文件例如proxyServer.conf，添加如下内容&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;## Basic reverse proxy server
upstream dockerServer  {
    ip_hash;
    server 10.128.163.121:7080;
    server 10.128.163.121:17080;
}

upstream dockerServerSSL  {
    ip_hash;
    server 10.128.163.121:7443;
    server 10.128.163.121:17443;
}

server {
    listen 80;
    server_name  10.128.163.121;

    ##access_log  logs/60.access.log  main;
    error_log  logs/60.error.log;
    root   html;
    index  index.html index.htm index.php;

    ## send request back to apache ##
    location / {
        proxy_pass  http://dockerServer ;

        #Proxy Settings
        proxy_redirect     off;
        proxy_set_header   Host             $host;
        proxy_set_header   X-Real-IP        $remote_addr;
        proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;
        proxy_next_upstream error timeout invalid_header http_500 http_502 http_503 http_504;
        proxy_max_temp_file_size 0;
        proxy_connect_timeout      90;
        proxy_send_timeout         90;
        proxy_read_timeout         90;
        proxy_buffer_size          4k;
        proxy_buffers              4 32k;
        proxy_busy_buffers_size    64k;
        proxy_temp_file_write_size 64k;
   }
}
server {
    listen 443;
    server_name  10.128.163.121;
    ssl on;
    ssl_certificate /etc/nginx/conf.d/server.crt;
    ssl_certificate_key /etc/nginx/conf.d/server.key;

    ##access_log  logs/60.access.log  main;
    error_log  logs/60.error.log;
    root   html;
    index  index.html index.htm index.php;

    ## send request back to apache ##
    location / {
        proxy_pass  https://dockerServerSSL ;

        #Proxy Settings
        proxy_redirect     off;
        proxy_set_header   Host             $host;
        proxy_set_header   X-Real-IP        $remote_addr;
        proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;
        proxy_next_upstream error timeout invalid_header http_500 http_502 http_503 http_504;
        proxy_max_temp_file_size 0;
        proxy_connect_timeout      90;
        proxy_send_timeout         90;
        proxy_read_timeout         90;
        proxy_buffer_size          4k;
        proxy_buffers              4 32k;
        proxy_busy_buffers_size    64k;
        proxy_temp_file_write_size 64k;
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意点：
1. https需要单独配置，由于后端server在https下也要工作，因为某些页面安全性要求较高，需要转成https的。
2. 这里使用的是ip_hash的方式做负载均衡，但是也有一定的缺陷，即在代理访问的情况下客户端ip有可能是会发生改变的，还有就是ip在负载均衡上均衡比较困难。
3. https的crt和key需要&lt;a href=&#34;http://www.lovelucy.info/nginx-ssl-certificate-https-website.html&#34;&gt;自己生成&lt;/a&gt;。
另外这个Nginx 是跑在宿主机上的，修改配置有要执行reload命令使其生效。&lt;/p&gt;

&lt;h2 id=&#34;session-persistence&#34;&gt;session persistence&lt;/h2&gt;

&lt;p&gt;生产环境需要将一个用户的请求要路由到同一个server上面，因为server很多的业务处理还是需要server里面的session配合。上面用ip_hash方式做load balance，但是考虑到用户使用proxy或者流量不均衡等因素。还是要使用session sticky的方式。
Nginx默认不支持session sticky，需要重新编译安装这个插件；因为直接使用公司的Nginx版本，所以懒得重新编译了。使用很简单，直接拷贝个bin文件，然后修改成这个样子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;upstream dockerServer  {
      sticky name=yourname httponly path=/ hash=md5;
       server 10.128.163.121:17080;
       server 10.128.163.121:7080;
   }
   
  upstream dockerServerSSL  {
     sticky name=yourname httponly path=/ hash=md5;
     server 10.128.163.121:17443;
     server 10.128.163.121:7443;
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样直接访问 &lt;a href=&#34;http://10.128.163.121&#34;&gt;http://10.128.163.121&lt;/a&gt; 即可，Nginx会自动路由请求到某一个server上。因为sticky是会话级别的，关掉浏览器会话就结束了。如果重新访问用户可能会被路由到另一个server上，可以通过查询Apache的accesslog来确认。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>deadlock of mysql</title>
      <link>http://compasses.github.io/2015/06/26/deadlock-of-mysql/</link>
      <pubDate>Fri, 26 Jun 2015 15:45:07 +0800</pubDate>
      <author>gnhe2009@gmail.com (Jet He)</author>
      <guid>http://compasses.github.io/2015/06/26/deadlock-of-mysql/</guid>
      <description>&lt;p&gt;没有想到在看似简单的场景里面也能遇到mysql的deadlock。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[Thu Jun 25 05:18:40.589897 2015] [:error] [pid 737] [client 172.17.42.1:41290] WordPress database error Deadlock found when trying to get lock; try restarting transaction for query UPDATE `wp_usermeta` SET `meta_value` = &#39;a:2:{s:64:\\&amp;quot;1161a6271c528045db428cc8698bbc8e3e26ad4fb9d7436e32cbbe01a00079d0\\&amp;quot;;i:1436419120;s:64:\\&amp;quot;bf2e3582e17c7dfa1e6b02c700f537b8095f2b31ef58e4b448939eb9406e11f7\\&amp;quot;;i:1435382320;}&#39; WHERE `user_id` = 188 AND `meta_key` = &#39;session_tokens&#39; made by require(&#39;wp-blog-header.php&#39;), require_once(&#39;wp-includes/template-loader.php&#39;), do_action(&#39;template_redirect&#39;), call_user_func_array, anw_template_redirect, ANW_Base_Controller-&amp;gt;process, call_user_func, ANW_AccountOnePage_Controller-&amp;gt;authenticate, wp_signon, wp_set_auth_cookie, WP_Session_Tokens-&amp;gt;create, WP_Session_Tokens-&amp;gt;update, WP_User_Meta_Session_Tokens-&amp;gt;update_session, WP_User_Meta_Session_Tokens-&amp;gt;update_sessions, update_user_meta, update_metadata
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是wordpress本身的缺陷导致的，死锁的场景也是不复杂。即session_tokens的更新机制所致。
Session_tokens的更新是随着用户的login和 logout 更新的。Login时会增加session_tokens, 在不同的 浏览器 login会增加新的 tokens，在 logout时会删除这个 tokens。
这个死锁用户有两个 session，场景可能就是不同的浏览器同时做 login或者 logout，或者一个 login另一个 logout。看这个环境上有大量的用户存在，并且每个用户至多有两个 session，也只有跑性能脚本会有这个问题。现实情况比较难复现。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                /**
                * Update a user&#39;s sessions in the usermeta table.
                *
                * @since 4.0.0
                * @access protected
                *
                * @param array $sessions Sessions.
                */
                protected function update_sessions( $sessions ) {
                                if ( ! has_filter( &#39;attach_session_information&#39; ) ) {
                                                $sessions = wp_list_pluck( $sessions, &#39;expiration&#39; );
                                }

                                if ( $sessions ) {
                                                update_user_meta( $this-&amp;gt;user_id, &#39;session_tokens&#39;, $sessions );
                                } else {
                                                delete_user_meta( $this-&amp;gt;user_id, &#39;session_tokens&#39; );
                                }
                }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看到这里应该要在仔细深入了解下mysql的加锁机制，当然这个会比较复杂，也不能一蹴而就。整体上重新熟悉下。
事务的隔离级别有四种，分别是READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ、SERIALIZEABLE。mysql默认的是可重复读。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;MariaDB [(none)]&amp;gt; show global variables like &#39;%isolation%&#39;;
+---------------+-----------------+
| Variable_name | Value           |
+---------------+-----------------+
| tx_isolation  | REPEATABLE-READ |
+---------------+-----------------+
1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;INNODB支持所有的事务隔离级别，但是MVCC只在REPEATABLE READ 和READ COMMITTED两个隔离级别下工作。
回到开始的问题。session_tokens 是真对用户在不同的终端上登录时进行更新的，value是个array，如上代码所示。如果同一个用户在两个终端上，可以是不同的浏览器即可，就会有不同的session_tokens，在登录登出的时候就会update改用户的数据，即同一行数据就可能产生死锁。这里必须是同时有两个事务。
现实中同一个用户在两个终端同时操作的可能性不大，但是也很难说。这也说明了wordpress的代码不够健壮吧。当然这里的死锁也并不可怕，INNODB会将持有最少行级排它锁的事务进行回滚。锁机制的了解还是要多多实践，网上也有较好的&lt;a href=&#34;http://hedengcheng.com/?p=771&#34;&gt;文章参考&lt;/a&gt;。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Docker Docker</title>
      <link>http://compasses.github.io/2015/06/19/docker-docker/</link>
      <pubDate>Fri, 19 Jun 2015 17:45:07 +0800</pubDate>
      <author>gnhe2009@gmail.com (Jet He)</author>
      <guid>http://compasses.github.io/2015/06/19/docker-docker/</guid>
      <description>&lt;p&gt;一直想把本地的开发环境切换到docker上，由于公司的CI出来的运行环境是docker的，所以把本地开发环境打造成docker的应该也很简单了。&lt;/p&gt;

&lt;p&gt;首先安装虚拟机，使用Vmplayer，下载Ubuntu的安装镜像文件，安装会非常简单。接下来就是docker的安装，docker安装依照&lt;a href=&#34;https://docs.docker.com/installation/ubuntulinux/&#34;&gt;官网&lt;/a&gt;即可&lt;/p&gt;

&lt;p&gt;公司的镜像是基于Ubuntu+wordpress+Apache，MySQL在宿主机上。运行container的时候带上相应的参数，这里主要是端口映射，将docker里面的80端口映射到宿主机上的某一个端口例如7080，最后运行起来类似这个样子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CONTAINER ID        IMAGE               COMMAND                CREATED             STATUS              PORTS                                                               NAMES
ff1ad6f22e91        eshop_612:latest    &amp;quot;/var/eshop/install/   31 hours ago        Up 31 hours         0.0.0.0:7022-&amp;gt;22/tcp, 0.0.0.0:7080-&amp;gt;80/tcp, 0.0.0.0:7443-&amp;gt;443/tcp   eshop_instance_7080  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;开始遇到一个问题就是这个端口的映射问题，起来后外部访问时还是用的宿主机的Apache，后续停掉宿主机的Apache，目的是干掉80监听端口，在docker里面增加proxy。后面就一路畅通了。&lt;/p&gt;

&lt;p&gt;修改源码如何更新到docker里面是个麻烦的事情，如果有个外挂文件目录的功能就好了，现在只能是修改后的代码传到docker里面。其实传代码也很简单，相比以前编写C++代码，先把本地代码传到Linux服务器上进行编译，编译完再传到运行的服务器上，已经简单多了。现在做的只是把修改后的代码通过filezilla传到docker里面，然后浏览器访问就ok了。&lt;/p&gt;

&lt;p&gt;dokcer的开发环境相对于本地的开发环境速度上有个质的飞跃，由于本地是XAMPP的，然后在windows上。很显然web的开发环境更适宜运行在docker里面了。&lt;/p&gt;

&lt;p&gt;当然还有个非常大的优点，你可以运行任意多个container，每个container里面的code版本可以不一样啊，尤其在多版本并行开发的时候，带来的开发体验是本地不能有的。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>libuv 初认识</title>
      <link>http://compasses.github.io/2015/06/03/libuv-%E5%88%9D%E8%AE%A4%E8%AF%86/</link>
      <pubDate>Wed, 03 Jun 2015 19:45:07 +0800</pubDate>
      <author>gnhe2009@gmail.com (Jet He)</author>
      <guid>http://compasses.github.io/2015/06/03/libuv-%E5%88%9D%E8%AE%A4%E8%AF%86/</guid>
      <description>

&lt;p&gt;说明： 本篇文章主要从&lt;a href=&#34;http://nikhilm.github.io/uvbook/&#34;&gt;An Introduction to libuv&lt;/a&gt;这本书翻译学习而来。&lt;/p&gt;

&lt;h2 id=&#34;开始&#34;&gt;开始&lt;/h2&gt;

&lt;p&gt;libuv是NodeJS的底层库，实现了异步、事件驱动的编程模式。主要功能就是实现了事件循环，基于I/O或者其他事件的通知回调。比如广泛使用回调的定时器、非阻塞的网络通信、异步的文件读取、子线程相关的通信等等。&lt;/p&gt;

&lt;h3 id=&#34;事件循环&#34;&gt;事件循环&lt;/h3&gt;

&lt;p&gt;libuv的编译就不用多说，参考libuv的&lt;a href=&#34;https://github.com/libuv/libuv&#34;&gt;github网址&lt;/a&gt;。就能轻松搞定。我是在Linux上做的相关实验，版本是： Linux ubuntu 3.16.0-33-generic #44~14.04.1-Ubuntu SMP Fri Mar 13 10:33:29 UTC 2015 x86_64 x86_64 x86_64 GNU/Linux。&lt;/p&gt;

&lt;p&gt;先从运行一个程序开始：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;quot;uv.h&amp;quot;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;

int main() {
    uv_loop_t *loop = malloc(sizeof(uv_loop_t));
    uv_loop_init(loop);
    printf(&amp;quot;Now quitting.\n&amp;quot;);
    uv_run(loop, UV_RUN_DEFAULT);
    uv_loop_close(loop);
    free(loop);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编译要使用gyp，因为源码包里面带有相应的samples，根据samples很容易的写出一个gyp 的build文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &#39;targets&#39;: [
    {
      &#39;dependencies&#39;: [&#39;../../uv.gyp:libuv&#39;],
      &#39;target_name&#39;: &#39;helloword&#39;,
      &#39;type&#39;: &#39;executable&#39;,
      &#39;sources&#39;: [
        &#39;main.c&#39;,
      ]
    }
  ],
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后执行** gyp &amp;ndash;format=make -Duv_library=static_library &amp;ndash;depth=$PWD build.gyp &lt;strong&gt;生产相应的makefile，最后直接执行&lt;/strong&gt;make**，就会生成自己想要的可执行文件。
gyp算上一个神器，比起自己写makefile轻松了很多，而且在跨平台方面也表现很好，后续有时间也好好学习下。
待续。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>同步、异步、阻塞、非阻塞I/O</title>
      <link>http://compasses.github.io/2015/05/24/%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9Ei/o/</link>
      <pubDate>Sun, 24 May 2015 14:45:07 +0800</pubDate>
      <author>gnhe2009@gmail.com (Jet He)</author>
      <guid>http://compasses.github.io/2015/05/24/%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9Ei/o/</guid>
      <description>&lt;p&gt;NodeJS倡导异步编程，高并发，高性能。他自然是异步非阻塞I/O。非阻塞I/O是不是就是异步的，跟异步编程又有什么区别呢？写到这里突然想到了大学里的辅导员，刚入大学的第一次开会，就告诫我们，&lt;strong&gt;学数学最重要的就是概念，概念不清就什么都学不好&lt;/strong&gt;。我深深记住了这句话，受用至今。&lt;/p&gt;

&lt;p&gt;先看看阻塞和非阻塞，阻塞，顾名思义，即在读取数据时，阻塞在等待数据，或者监听事件时阻塞，有新的数据或者事件，事件是泛化概念，数据到达也是个事件。可以用事件代替一切吧，统称event。非阻塞即调用接口触发某种event，没有任何event也不会阻塞，而是直接返回。&lt;/p&gt;

&lt;p&gt;非阻塞返回后干什么，这就牵扯到同步和异步之分了。阻塞就不用多说了显而易见的同步行为。在非阻塞的基础上再进行区分同步和异步。非阻塞在Linux上一般都会使用性能较好的epoll实现，epoll会轮询这些阻塞上的事件，有事务返回便会调用相应的处理流程。那这个是不是异步的呢，还是要看在哪个角度上说，站在非阻塞的角度上，因同时处理多个事件，增加并发性，多个阻塞event进行了异步处理；在轮询线程上说，因还是在不断的轮询它所关心的事件，某一个事件返回时就要进行相应的处理，在这个角度上讲，这个线程可以同步处理多个异步事件，它是同步的。但是在一个框架上，如果实现了这种同步处理多个异步事件的行为，在基于这个框架上进行编码的时候，要进行事件回调，这也是NodeJS的行为。NodeJS需要异步编程思想，但是NodeJS是单线程的，NodeJS就是要不断回调那些需要异步处理的事件，但是异步编程会让代码变得难以维护和调试，&lt;a href=&#34;http://www.zhihu.com/question/19585576&#34;&gt;这个链接&lt;/a&gt;有较好的讨论。&lt;/p&gt;

&lt;p&gt;AIO是纯正的异步I/O且非阻塞的，本来应该想epoll一样被广泛使用，获得大赞的，但目前看来被&lt;a href=&#34;http://www.wzxue.com/linux-kernel-aio%E8%BF%99%E4%B8%AA%E5%A5%87%E8%91%A9/&#34;&gt;诟病太多&lt;/a&gt;。例如内核实现的AIO只能是直接I/O的方式，不能有效的利用系统缓存。glibc的AIO利用线程池模拟出来的，但是存在一系列的bug和&lt;a href=&#34;http://www.lenky.info/archives/2013/01/2165&#34;&gt;缺陷&lt;/a&gt;。也因此NodeJS的作者重新封装了一个异步非阻塞的库： libuv。&lt;/p&gt;

&lt;p&gt;由于NodeJS的异步编程思想，会让代码变得维护困难，调试也非常不直观，后面就出现了协程的思想。&lt;a href=&#34;https://bjouhier.wordpress.com/2012/03/11/fibers-and-threads-in-node-js-what-for/&#34;&gt;这篇文章&lt;/a&gt;对NodeJS的协程思想进行了介绍。&lt;a href=&#34;https://github.com/laverdet/node-fibers&#34;&gt;node-fibers&lt;/a&gt;尝试去协程花NodeJS的层层回调。这个module值得研究一下。后续会有个单独的文章对其进行详细的介绍。&lt;/p&gt;

&lt;p&gt;NodeJS底层事件循环使用了libuv库，跨平台Linux下使用libev实现，windows下使用IOCP实现，后续也要仔细研究下这个库，应用广泛的东西，必定是好东西，值得学习的东西。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>