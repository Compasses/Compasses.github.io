<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Web on 三十重围</title>
    <link>http://www.heguangnan.com/tags/web/</link>
    <description>Recent content in Web on 三十重围</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-EN</language>
    <lastBuildDate>Thu, 28 Jan 2016 21:48:40 +0800</lastBuildDate>
    
	<atom:link href="http://www.heguangnan.com/tags/web/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>input 和 textarea的长度限制问题</title>
      <link>http://www.heguangnan.com/post/input-%E5%92%8C-textarea%E7%9A%84%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6%E9%97%AE%E9%A2%98/</link>
      <pubDate>Thu, 28 Jan 2016 21:48:40 +0800</pubDate>
      
      <guid>http://www.heguangnan.com/post/input-%E5%92%8C-textarea%E7%9A%84%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6%E9%97%AE%E9%A2%98/</guid>
      <description>一些敏感的页面应用，对用户的输入都有较多的限制，长度便是其中之一。但是最近遇到一个长度限制的问题。HTML对 input 和 textarea都有maxlength 的属性，该属性的解释就是允许输入字段的最大字符数。这里说的字符数，对英文是完全没有问题的，能做到精确控制输入长度，但是汉字的长度就会有前后不一致的问题。
编码问题 互联网上使用最为广泛的就是UTF-8的编码方式，查看网页源码的时候基本上都能看到字符集的编码设置：
&amp;lt;meta charset=&amp;quot;utf-8&amp;quot;&amp;gt;  UTF-8是Unicode的一种实现方式。是一种变长编码，想更多了解的可以看这篇文章，基本上能让大家明白。所以造成这个问题的主因也是由于变长编码导致的。javascript把每个汉字当成一个字符，而在后台PHP是按照UTF-8计算，每个汉字由三个字节组成，故中文输入到了后台长度会变成字数的三倍。所以在输入框里面有中文的时候maxlength限制就不再可靠了。
精确获取字符长度 由于maxlength不再可靠，需要有方法获取任意输入的字节数。针对中文输入使用将其转码并使用特殊方法计算其长度便可达成精确控制输入长度的目的。encodeURIComponent方法是比较好用的：
The encodeURIComponent() function encodes a Uniform Resource Identifier (URI) component by replacing each instance of certain characters by one, two, three, or four escape sequences representing the UTF-8 encoding of the character (will only be four escape sequences for characters composed of two &amp;quot;surrogate&amp;quot; characters).  该方法能将UTF-8编码的输入文字转码成对应的多字节字符串。 例如：
encodeURIComponent(&#39;我的问题&#39;) &amp;quot;%E6%88%91%E7%9A%84%E9%97%AE%E9%A2%98&amp;quot;  每个中文字转成三个字节冠以%开头。匹配出这样的pattern并计算长度，使用javascript的正则表达式:
/%[A-F\d]{2}/g  并临时替换成一个英文字符，那么长度就可以准确得到了：
encodeURIComponent(&#39;abc我的问题abc&#39;).replace(/%[A-F\d]{2}/g, &#39;i&#39;) &amp;quot;abciiiiiiiiiiiiabc&amp;quot; encodeURIComponent(&#39;abc我的问题abc&#39;).</description>
    </item>
    
    <item>
      <title>Apache Cache 研究</title>
      <link>http://www.heguangnan.com/post/apache-cache-%E7%A0%94%E7%A9%B6/</link>
      <pubDate>Wed, 09 Dec 2015 21:48:04 +0800</pubDate>
      
      <guid>http://www.heguangnan.com/post/apache-cache-%E7%A0%94%E7%A9%B6/</guid>
      <description>Apache 作为一个hosting server，在2.2版本以上的也有较为强大的缓存功能。使其不管是作为web server还是代理server都能实现访问加速。 Apache支持两种cache模块，分别是mod_cache和mod_file_cache。mod_file_cache较为简单粗暴，cache那种不轻易改变的或者对实效性要求不高的文件较为适合，因为后台更新了缓存不能及时更新，需要一个周期或者重启Apache。 mod_cache是一种较为智能有效的、感知HTTP协议的cache方式，它有两种实现方案mod_mem_cache和mod_disk_cache，顾名思义mem是将响应内容缓存到内存中，disk是将响应内容缓存到磁盘中。mem是代价比较高的，因其缓存到内存中就会不可避免的导致Apache占用的系统内存增加。因此disk的缓存方案多被推荐使用。 具体详细的信息可以参考Apache的官方文档Caching Guide
浏览器刷新原则 不同的请求header，cache的响应行为是不一样的，所以要搞清楚你的请求header是什么样的，响应header是什么样的，搞清楚才能较好的测试Apache的cache。 这里使用的测试浏览器是Firefox，也推荐使用Firefox，禁止Firefox的本地cache。 一般的请求头，类似点击页面链接：
Accept text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Encoding gzip, deflate Accept-Language zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3 Connection keep-alive Cookie timeOffset=-480; timeOffset=-480; wp-settings-time-1=1445853102; PHPSESSID=ohiq63apsjmvsrl443778j22g6; ANW_TRACE_ID=25a6e917-0a0b-4580-a989-14ef71368ea1; CART_ITEMS=%5B%5D Host 10.128.163.72 User-Agent Mozilla/5.0 (Windows NT 6.1; WOW64; rv:42.0) Gecko/20100101 Firefox/42.0  F5 刷新的请求头：
 Accept text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Encoding gzip, deflate Accept-Language zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3 Cache-Control max-age=0 Connection keep-alive Cookie timeOffset=-480; timeOffset=-480; wp-settings-time-1=1445853102; PHPSESSID=ohiq63apsjmvsrl443778j22g6; ANW_TRACE_ID=25a6e917-0a0b-4580-a989-14ef71368ea1; CART_ITEMS=%5B%5D Host 10.128.163.72 User-Agent Mozilla/5.0 (Windows NT 6.1; WOW64; rv:42.</description>
    </item>
    
    <item>
      <title>HTTP Cache</title>
      <link>http://www.heguangnan.com/post/web-cache/</link>
      <pubDate>Fri, 27 Nov 2015 17:45:24 +0800</pubDate>
      
      <guid>http://www.heguangnan.com/post/web-cache/</guid>
      <description>目前估计很少有网站不会使用http cache了，http cache 的合理使用能极大的提高用户体验，另一方面还能减轻server端的负担。特别现在流行https，使用好http cache也变得更加重要了。
相关HTTP header字段 Last-Modified和ETag 两者的功能类似，一个是文件的最近一次的修改时间，一个是针对这个资源文件生成的tag。都是server端的返回。刷新页面时，请求头里面会带上If-Modified-Since或者 If-None-Match。 但是Etag并不推荐使用，原因就是不同的server对Etag的生成算法可能不统一，特别在集群server的情况下。
Pragma 纯协议上的指令，对请求响应链路上的所有代理使用。例如如果pragma：no-chache，则请求在请求响应链上的任意节点都不会被缓存，因其于cache-control：no-chache意义一致。
Expires set response headers，对某个响应设置个超时时间，一般优先级不高，如果存在max-age的话，这个字段几乎不起作用。
Cache-Control public：标识验证后的respons可被缓存的。 no-store：任何情况下不缓存，并尽量不要保存到磁盘中。不缓存的资源并不能保证不被保存到磁盘中。例如浏览器的后退键，可能会导致看到过期的页面。 no-cache: 强制提交校验请求，严格模式，也即不缓存该响应。 must-revalidate: 缓存必须遵守任何的刷新规则，如果缓存超时必须重新发起请求，或者是条件请求。 proxy-revalidate： 和must 一样，只对proxy cache有效，对中间有cache server的情况，该字段指导cache server的验证方式和条件。 max-age: 指定刷新超时时间，即cache的超时时间。 s-maxage: 和 max-age一样，如果cache不是private的，他会指明cache servers使用这个s-maxage，针对public的cache有效，其会覆盖max-age。
vary 通过vary告诉http cache，寻找缓存对象时需要考虑的头域字段。比如：浏览器发了两个request，一个带有accept-encoding， 一个没有。http 缓存的时候会带上这个vary标记，表示只有带有accept-encoding的缓存对象才能是使用。达到的效果就是request里面带有accept-encoding的请求，响应缓存只能被这样的请求获取。
vary的不同会控制请求的发送数量。例如vary:*，表明每个request都是不同的。 简单的理解vary用来区分请求的差别，识别出不同的request。 vary的其他取值：user-agent, 让响应区分不同的agent；Referer, 区分这个request是从哪个页面而来。cookie, 不同认证信息不同的 request。vary指定的那些值就会影响浏览器的cache策略。
需要注意的几个问题 https 证书问题 如果是无效的证书，会导致缓存无法完全起用。本地测试是doc无法被cache，静态资源还是可以的。当然这跟浏览器的行为也有关系，Firefox里面添加例外证书变成合法的就可以正常缓存了。chrome的证书比较严格不好把红叉叉去掉。
expires和max-age 优先级问题 当response头域里面两者都包含时，浏览器会优先选用max-age，当然这是我本地的测试结果。所有的情况可能难以覆盖，比如移动端的浏览器，其他的浏览器，除了Firefox、chrome、IE等等以外的。 另外就是expires是http1.0里面的，max-age在http1.1被引入，但是这篇文章建议最好两者都带上正确的值，或者只带上max-age。
Conditional Requests 条件请求是当浏览器发现资源超时时，如过了max-age或者expires date，会发起条件请求，如果server发现资源变化了会回复200 ok，否则回复304的status code。正确情况下资源cache后，浏览器是不会发条件请求的，直到资源超时后。当然也不排除某些浏览器会不停的发conditional request，更为详细的介绍，请看这里。
静态资源缓存 针对静态资源，更新时更加推荐使用变更文件名的方式，例如让文件名包含一个版本号的方式。这种比文件末尾增加query string更加有效，例如有些中间proxy就不会缓存带有查询字符的url。
PHP配合apache 实现静态资源版本控制 针对静态资源的cache设置，这个github有较好的配置模板做参考。基本上enmod headers即可。 针对静态文件php代码里面插入版本号，一般为时间戳或者数据库里面的更新时间：</description>
    </item>
    
  </channel>
</rss>