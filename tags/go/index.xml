<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Go on 三十重围</title>
    <link>http://compasses.github.io/tags/go/</link>
    <description>Recent content in Go on 三十重围</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-EN</language>
    <managingEditor>gnhe2009@gmail.com (Jet He)</managingEditor>
    <webMaster>gnhe2009@gmail.com (Jet He)</webMaster>
    <copyright>(c) 2015 Jet He.</copyright>
    <lastBuildDate>Fri, 23 Oct 2015 22:45:07 +0800</lastBuildDate>
    <atom:link href="http://compasses.github.io/tags/go/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>golang interface analysis by gdb</title>
      <link>http://compasses.github.io/2015/10/23/golang-interface-analysis-by-gdb/</link>
      <pubDate>Fri, 23 Oct 2015 22:45:07 +0800</pubDate>
      <author>gnhe2009@gmail.com (Jet He)</author>
      <guid>http://compasses.github.io/2015/10/23/golang-interface-analysis-by-gdb/</guid>
      <description>&lt;p&gt;interface 在go语言中，是非常重要的一环，总有点让人感到很玄乎不定的感觉。官方的lib中有大量使用，似乎面向对象和动态绑定也能跟interface扯上关系。总之，如果能更好的理解interface的机理，就能更好的理解和使用Go了。&lt;/p&gt;

&lt;p&gt;interface的较为深层次的探讨在&lt;a href=&#34;http://research.swtch.com/interfaces&#34;&gt;这篇blog&lt;/a&gt;里面已经有较为详细的介绍。但是缺乏一些实践，本文遍结合此文，使用GDB实际研究一下。&lt;/p&gt;

&lt;p&gt;##interface 内部存储
interface的值，其实是两个指针的组合：data 和 tab。data 实际指向值的指针，tab是go runtime的一个struct：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// layout of Itab known to compilers
// allocated in non-garbage-collected memory
type itab struct {
    inter  *interfacetype

    _type  *_type

    link   *itab

    bad    int32
    unused int32
    fun    [1]uintptr // variable sized
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在运行时该结构会被runtime库计算出来，保证interface的正常运转。
使用&lt;strong&gt;go build -gcflags &amp;laquo;-N -l&amp;raquo;&lt;/strong&gt;编译便可以是用GDB来debug了。
断点断在最后一行代码，代码在最后列出。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) info locals
b = 200
s = {tab = 0x7ffff7e0f1c0, data = 0xc82000a3b0}
nothing = {_type = 0x4c1360, data = 0xc82000a430}
face = {tab = 0x0, data = 0x0}
any = {_type = 0x4e4a80, data = 0xc82000a3c0}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先看变量*s*，内部有个tab指针和data指针。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) p  *s.tab
$24 = {inter = 0x4dffa0, _type = 0x4e4a80, link = 0x0, bad = 0, unused = 0, fun = {4200784}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结构就是上面的itab的数据结构，其中的interfacetype 和 _type的结构分别为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type interfacetype struct {
    typ  _type

    mhdr []imethod

}
// Needs to be in sync with ../cmd/internal/ld/decodesym.go:/^func.commonsize,
// ../cmd/internal/gc/reflect.go:/^func.dcommontype and
// ../reflect/type.go:/^type.rtype.
type _type struct {
    size       uintptr
    ptrdata    uintptr // size of memory prefix holding all pointers
    hash       uint32
    _unused    uint8
    align      uint8
    fieldalign uint8
    kind       uint8
    alg        *typeAlg

    // gcdata stores the GC type data for the garbage collector.
    // If the KindGCProg bit is set in kind, gcdata is a GC program.
    // Otherwise it is a ptrmask bitmap. See mbitmap.go for details.
    gcdata  *byte
    _string *string
    x       *uncommontype

    ptrto   *_type

    zero    *byte // ptr to the zero value for this type
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;分别看下里面的内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) p  *s.tab.inter
$26 = {typ = {size = 16, ptrdata = 16, hash = 3958674519, _unused = 0 &#39;\000&#39;, align = 8 &#39;\b&#39;, fieldalign = 8 &#39;\b&#39;, kind = 20 &#39;\024&#39;, alg = 0x592770 &amp;lt;runtime.algarray+240&amp;gt;,
    gcdata = 0x537142 &amp;quot;\003\004\005\006\a\b\t\n\r\016\017\020\021\022\025\026\031\032\033\037,568&amp;gt;?Ur\236\237\325\365\377&amp;quot;, _string = 0x5161d0, x = 0x4e0018, ptrto = 0x4b6e80,
    zero = 0x539c40 &amp;lt;runtime.zerovalue&amp;gt; &amp;quot;&amp;quot;}, mhdr = {array = 0x4e0000, len = 1, cap = 1}}
(gdb) p  *s.tab._type
$27 = {size = 8, ptrdata = 0, hash = 1148337467, _unused = 0 &#39;\000&#39;, align = 8 &#39;\b&#39;, fieldalign = 8 &#39;\b&#39;, kind = 139 &#39;\213&#39;, alg = 0x5926d0 &amp;lt;runtime.algarray+80&amp;gt;,
  gcdata = 0x537140 &amp;quot;\001\002\003\004\005\006\a\b\t\n\r\016\017\020\021\022\025\026\031\032\033\037,568&amp;gt;?Ur\236\237\325\365\377&amp;quot;, _string = 0x5161c0, x = 0x4e4ac8, ptrto = 0x4e4d20,
  zero = 0x539c40 &amp;lt;runtime.zerovalue&amp;gt; &amp;quot;&amp;quot;}
(gdb) p  *s.tab.inter.typ._string
$28 = 0x50b930 &amp;quot;main.Stringer&amp;quot;
(gdb) p  *s.tab._type._string
$29 = 0x50b920 &amp;quot;main.Binary&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以清晰的看出，itab的type是interface所包含值的type信息：&lt;strong&gt;main.Binary&lt;/strong&gt;，而tab的interface type为该interface的类型信息: &lt;strong&gt;main.Stringer&lt;/strong&gt;。
他们的size是不一样的。Binary的size为8个字节，而interface是16个字节。
&lt;strong&gt;想想为啥interface是16个字节的大小？这里可以大胆猜测16个字节是系统内存管理的对齐对齐最小字节数，即libc之前的内存管理里面分配内存都是以16字节作为对齐的，这样也是为了方便内存管理吧。&lt;/strong&gt;
要想搞清楚tab里面所有变量的意义，那是不可能的了，在GDB调试过程中，发现中间穿插大量的汇编代码，特别是runtime库实现interface计算过程中。
继续，s的data也是个指针可以直接将其值打印出来：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) p *uint64(s.data)
$22 = 200
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为我们事先知道该值类型为64位的uint型。
接着看下any和nothing这两个变量。该两个变量有着不同的类型。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) p nothing
$51 = {_type = 0x4c1360, data = 0xc82000a430}
(gdb) p any
$52 = {_type = 0x4e4a80, data = 0xc82000a3c0}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;针对interface go的编译器有两种的内存优化策略，就像上面两个变量，他们就不再有itab了，只是type，原因是他们没有方法集。上面文章中说的第二种优化策略，在实际测试中并没有验证出来，即如果interface里面的data值是32位的，则该data字段会直接存该值，不会用指针多一层引用了，即代码中的s32。&lt;/p&gt;

&lt;p&gt;通过上面可以看出interface是runtime的产物，是go运行时的对象。这个很像C++中的虚函数表的行为。
从而也可以意识到interface是类型和接口同时兼备的，任何变量都可以赋值给interface，如果该变量是没有接口方法的话，那么interface就是只存其类型信息，否则如果有接口方法，就会多一个itab出来，里面会有其对应的函数列表。
&lt;strong&gt;这样也就很容易理解，interface可以包容任何变量了，因为在运行时，interface变量会记录其所包含值的类型信息。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;##interface使用
关于interface的使用方面，有不少文章做了介绍，比如：&lt;a href=&#34;http://jordanorelli.com/post/32665860244/how-to-use-interfaces-in-go&#34;&gt; How to use interfaces in Go&lt;/a&gt;和&lt;a href=&#34;https://golang.org/doc/effective_go.html#interfaces&#34;&gt;Effective Go&lt;/a&gt;。
从上面部分可以了解到，interface是一种运行时类型，既有函数集还有数据。interface本身定义只能定义方法集，你所要做的就是把这些方法赋予某个Object上面。这样Object就有了这个interface的能力，任意使用这个interface作为参数或者值的地方，Object也就可以畅通无阻了。
interface可以接纳任意类型，因interface内部的type信息是完备的：用type switch 可以获取interface内部value的类型信息，如下所示。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Stringer interface {
    String() string
}

var value interface{} // Value provided by caller.
switch str := value.(type) {
case string:
    return str
case Stringer:
    return str.String()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;interface 更为抽象化的接口，通过interface来定义你的行为方法，行为方法里面会对对象数据产生变化，这个也是需要进行隔离的。跟与C++编码那种面向对象的思想有点出入，看起来不是那么直观。面向对象即先定义对象，和对象的行为。Go里面也是可以定义自己的对象和方法，然后再把这些方法抽象成一个类型：interface，interface就可以使用在函数接口当中，其实此时传递的时候还是你所定义的对象。&lt;/p&gt;

&lt;p&gt;总体上感觉interface比面向对象更抽象了一层，需要在更多的实际开发过程中慢慢体会。&lt;/p&gt;

&lt;p&gt;附：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
     &amp;quot;fmt&amp;quot;
     &amp;quot;strconv&amp;quot;
)

type Stringer interface {
    String() string
}

func ToString(any interface{}) string {
    if v, ok := any.(Stringer); ok {
        return v.String()
    }
    switch v := any.(type) {
    case int:
        return strconv.Itoa(v)
    case float32:
        return strconv.FormatFloat(float64(v), &#39;g&#39;, -1, 32)
    }
    return &amp;quot;???&amp;quot;
}

type Binary uint64
type Binary32 uint32

func (i Binary) String() string {
    return strconv.FormatUint(i.Get(), 2)
}

func (i Binary) Get() uint64 {
    return uint64(i)
}

func (i Binary32) String() string {
    return strconv.FormatUint(uint64(i.Get()), 2)
}

func (i Binary32) Get() uint64 {
    return uint64(i)
}

func main() {
    
     b := Binary(200)
     b32 := Binary32(200)
    
     s := Stringer(b)
     s32 := Stringer(b32)
    
     any := (interface{})(b)
    
     fmt.Println(s.String())
     fmt.Println(s32.String())
    
     fmt.Println(ToString(any))
    
     var nothing interface{}

     nothing = uint64(200)
     fmt.Println(nothing)

     var face Stringer
    
     fmt.Println(face)
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Go Go</title>
      <link>http://compasses.github.io/2015/07/09/go-go/</link>
      <pubDate>Thu, 09 Jul 2015 17:45:07 +0800</pubDate>
      <author>gnhe2009@gmail.com (Jet He)</author>
      <guid>http://compasses.github.io/2015/07/09/go-go/</guid>
      <description>&lt;p&gt;最近在学习Go语言。认识Go语言是个偶然，首选是Docker容器的使用，Docker的兴起目前可谓风生水起，应用部署和各种云平台都在推行。其使用Go语言开发，之前没有听说过的。断断续续的找相关的博客、资料进行了解。发现Go 是有很多吸引人的地方，自己非常感兴趣，最近买的一本《Go Web编程》今天到手了。&lt;/p&gt;

&lt;p&gt;也说下自己的缘由，很多人都说Go 很容易上手，这应该对C系的开发人员而说的，Go语言的发明者也是C语言的作者，Go语言本身很多的语法、类型、结构等用法类似于C语言，如果编译运行的话二进制文件都能用GDB进行调试。Go语言是个集大成者，在里面你能看到或者重新认识一些语言特性，它有诸多动态语言特有的特性。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;首选想说的就是函数闭包，闭包函数在JavaScript里面应用的最广泛，用于各种回调处理、变量的scope控制等，在Go语言里面也有，使用起来几乎没有什么差别，也能当成变量传递等等。&lt;/li&gt;
&lt;li&gt;内置强大的数据结构，例如slice、map，开发的快捷易用性可以和Python媲美。slice 类似于Python、PHP里面的array，map也和Python里面的字典。&lt;/li&gt;
&lt;li&gt;interface的类型使用，interface让Go有了面向对象的能力，interface是非常有魔力的东西，应该会是非常广泛的，把面向对象的能力放大了。Go里面的反射功能也是依赖于interface，这篇文章&lt;a href=&#34;http://research.swtch.com/interfaces&#34;&gt;Go Data Structures: Interfaces&lt;/a&gt;有较深入的讲解。&lt;/li&gt;
&lt;li&gt;并发编程的支持，可以写并发执行的代码，通过go关键字来完成。goroutine确是是个好东西，用户层上的并发协程，能有效的利用多核计算能力。Go能原生的支持并发编程并能很好的利用多核能力是个极大的优势。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;有人说不能把Go作为偏向Web的语言，这应该是比较片面的。就像Python一样，一直都是当成工具使用，能快速的开发一些小工具，而现在呢，Python的Web框架为Python的流行应该是起了主要作用。Go的使用应该要偏向云平台开发、Web开发，高性能、高并发的场景。试想下Docker的流行，国内七牛公司对Go语言的推崇。&lt;/p&gt;

&lt;p&gt;Go相对于PHP、JAVA年轻很多，但自己相信它会成为后起之秀，也做好了这个准备。&lt;/p&gt;

&lt;p&gt;很高兴开启Go语言之旅。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>