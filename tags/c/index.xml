<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>C on 三十重围</title>
    <link>http://compasses.github.io/tags/c/</link>
    <description>Recent content in C on 三十重围</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-EN</language>
    <managingEditor>gnhe2009@gmail.com (Jet He)</managingEditor>
    <webMaster>gnhe2009@gmail.com (Jet He)</webMaster>
    <copyright>(c) 2015 Jet He.</copyright>
    <lastBuildDate>Wed, 03 Jun 2015 19:45:07 +0800</lastBuildDate>
    <atom:link href="http://compasses.github.io/tags/c/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>libuv 初认识</title>
      <link>http://compasses.github.io/2015/06/03/libuv-%E5%88%9D%E8%AE%A4%E8%AF%86/</link>
      <pubDate>Wed, 03 Jun 2015 19:45:07 +0800</pubDate>
      <author>gnhe2009@gmail.com (Jet He)</author>
      <guid>http://compasses.github.io/2015/06/03/libuv-%E5%88%9D%E8%AE%A4%E8%AF%86/</guid>
      <description>

&lt;p&gt;说明： 本篇文章主要从&lt;a href=&#34;http://nikhilm.github.io/uvbook/&#34;&gt;An Introduction to libuv&lt;/a&gt;这本书翻译学习而来。&lt;/p&gt;

&lt;h2 id=&#34;开始:1fb7be80e02e4b29d4cf88eae1d66804&#34;&gt;开始&lt;/h2&gt;

&lt;p&gt;libuv是NodeJS的底层库，实现了异步、事件驱动的编程模式。主要功能就是实现了事件循环，基于I/O或者其他事件的通知回调。比如广泛使用回调的定时器、非阻塞的网络通信、异步的文件读取、子线程相关的通信等等。&lt;/p&gt;

&lt;h3 id=&#34;事件循环:1fb7be80e02e4b29d4cf88eae1d66804&#34;&gt;事件循环&lt;/h3&gt;

&lt;p&gt;libuv的编译就不用多说，参考libuv的&lt;a href=&#34;https://github.com/libuv/libuv&#34;&gt;github网址&lt;/a&gt;。就能轻松搞定。我是在Linux上做的相关实验，版本是： Linux ubuntu 3.16.0-33-generic #44~14.04.1-Ubuntu SMP Fri Mar 13 10:33:29 UTC 2015 x86_64 x86_64 x86_64 GNU/Linux。&lt;/p&gt;

&lt;p&gt;先从运行一个程序开始：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;quot;uv.h&amp;quot;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;

int main() {
    uv_loop_t *loop = malloc(sizeof(uv_loop_t));
    uv_loop_init(loop);
    printf(&amp;quot;Now quitting.\n&amp;quot;);
    uv_run(loop, UV_RUN_DEFAULT);
    uv_loop_close(loop);
    free(loop);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编译要使用gyp，因为源码包里面带有相应的samples，根据samples很容易的写出一个gyp 的build文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &#39;targets&#39;: [
    {
      &#39;dependencies&#39;: [&#39;../../uv.gyp:libuv&#39;],
      &#39;target_name&#39;: &#39;helloword&#39;,
      &#39;type&#39;: &#39;executable&#39;,
      &#39;sources&#39;: [
        &#39;main.c&#39;,
      ]
    }
  ],
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后执行** gyp &amp;ndash;format=make -Duv_library=static_library &amp;ndash;depth=$PWD build.gyp &lt;strong&gt;生产相应的makefile，最后直接执行&lt;/strong&gt;make**，就会生成自己想要的可执行文件。
gyp算上一个神器，比起自己写makefile轻松了很多，而且在跨平台方面也表现很好，后续有时间也好好学习下。
待续。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>