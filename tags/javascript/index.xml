<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Javascript on 三十重围</title>
    <link>http://compasses.github.io/tags/javascript/</link>
    <description>Recent content in Javascript on 三十重围</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-EN</language>
    <managingEditor>gnhe2009@gmail.com (Jet He)</managingEditor>
    <webMaster>gnhe2009@gmail.com (Jet He)</webMaster>
    <copyright>(c) 2015 Jet He.</copyright>
    <lastBuildDate>Thu, 28 Jan 2016 21:48:40 +0800</lastBuildDate>
    <atom:link href="http://compasses.github.io/tags/javascript/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>input 和 textarea的长度限制问题</title>
      <link>http://compasses.github.io/2016/01/28/input-%E5%92%8C-textarea%E7%9A%84%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6%E9%97%AE%E9%A2%98/</link>
      <pubDate>Thu, 28 Jan 2016 21:48:40 +0800</pubDate>
      <author>gnhe2009@gmail.com (Jet He)</author>
      <guid>http://compasses.github.io/2016/01/28/input-%E5%92%8C-textarea%E7%9A%84%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6%E9%97%AE%E9%A2%98/</guid>
      <description>

&lt;p&gt;一些敏感的页面应用，对用户的输入都有较多的限制，长度便是其中之一。但是最近遇到一个长度限制的问题。HTML对 input 和 textarea都有maxlength 的属性，该属性的解释就是&lt;a href=&#34;http://www.w3school.com.cn/tags/att_input_maxlength.asp&#34;&gt;允许输入字段的最大字符数&lt;/a&gt;。这里说的字符数，对英文是完全没有问题的，能做到精确控制输入长度，但是汉字的长度就会有前后不一致的问题。&lt;/p&gt;

&lt;h2 id=&#34;编码问题&#34;&gt;编码问题&lt;/h2&gt;

&lt;p&gt;互联网上使用最为广泛的就是UTF-8的编码方式，查看网页源码的时候基本上都能看到字符集的编码设置：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;meta charset=&amp;quot;utf-8&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;UTF-8是Unicode的一种实现方式。是一种变长编码，想更多了解的可以看&lt;a href=&#34;http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html&#34;&gt;这篇文章&lt;/a&gt;，基本上能让大家明白。所以造成这个问题的主因也是由于变长编码导致的。javascript把每个汉字当成一个字符，而在后台PHP是按照UTF-8计算，每个汉字由三个字节组成，故中文输入到了后台长度会变成字数的三倍。所以在输入框里面有中文的时候maxlength限制就不再可靠了。&lt;/p&gt;

&lt;h2 id=&#34;精确获取字符长度&#34;&gt;精确获取字符长度&lt;/h2&gt;

&lt;p&gt;由于maxlength不再可靠，需要有方法获取任意输入的字节数。针对中文输入使用将其转码并使用特殊方法计算其长度便可达成精确控制输入长度的目的。&lt;strong&gt;encodeURIComponent&lt;/strong&gt;方法是比较好用的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;The encodeURIComponent() function encodes a Uniform Resource Identifier (URI) component by replacing each instance of certain characters by one, two, three, or four escape sequences representing the UTF-8 encoding of the character (will only be four escape sequences for characters composed of two &amp;quot;surrogate&amp;quot; characters).
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该方法能将UTF-8编码的输入文字转码成对应的多字节字符串。
例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;encodeURIComponent(&#39;我的问题&#39;)
&amp;quot;%E6%88%91%E7%9A%84%E9%97%AE%E9%A2%98&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;每个中文字转成三个字节冠以%开头。匹配出这样的pattern并计算长度，使用javascript的正则表达式:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/%[A-F\d]{2}/g
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;并临时替换成一个英文字符，那么长度就可以准确得到了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;encodeURIComponent(&#39;abc我的问题abc&#39;).replace(/%[A-F\d]{2}/g, &#39;i&#39;)
&amp;quot;abciiiiiiiiiiiiabc&amp;quot;
encodeURIComponent(&#39;abc我的问题abc&#39;).replace(/%[A-F\d]{2}/g, &#39;i&#39;).length
18
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;textarea-中的换行符&#34;&gt;textarea 中的换行符&lt;/h2&gt;

&lt;p&gt;与input相比，textarea还能输入回车换行，但是换行在javascript计算长度的时候却少计算一个字符，这样也会造成跟PHP后台不一致的情况，其实java后台也是一样的。
例如只有一个换行符的encode前端结果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;encodeURIComponent($(&#39;textarea&#39;).val())
&amp;quot;%0A&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而到了后台该换行符变成：&lt;strong&gt;0D 0A&lt;/strong&gt;。
产生这个问题的原因是换行符在HTTP&lt;a href=&#34;http://stackoverflow.com/questions/462348/string-length-differs-from-javascript-to-java-code&#34;&gt;传输的过程中发生转换&lt;/a&gt;，由‘\n’变成‘\r\n’。
因此在计算textarea值时在遇到换行符时记得长度额外加1。&lt;/p&gt;

&lt;h2 id=&#34;代码实现&#34;&gt;代码实现&lt;/h2&gt;

&lt;p&gt;既然问题原因找到了，解决的思路也基本清晰了，剩下的就是JS代码实现下了。
针对input：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $(&amp;quot;input&amp;quot;).on(&#39;keydown keyup paste&#39;,function(){
        var $that = $(this),
        maxlength = $that.attr(&#39;maxlength&#39;);

        if($.isNumeric(maxlength) &amp;amp;&amp;amp; maxlength &amp;gt; 0){
            var realLen = encodeURIComponent($that.val()).replace(/%[A-F\d]{2}/g, &#39;U&#39;).length;
            var currLen = $that.val().length;
            if (realLen &amp;gt; maxlength) {
                do {
                    $that.val($that.val().substr(0, currLen));
                    currLen --;
                } while (encodeURIComponent($that.val()).replace(/%[A-F\d]{2}/g, &#39;U&#39;).length &amp;gt; maxlength);
            }
        };
    });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;针对textarea：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $(&amp;quot;textarea&amp;quot;).on(&#39;keydown keyup paste&#39;,function(){
        var $that = $(this),
        maxlength = $that.attr(&#39;maxlength&#39;);

        if($.isNumeric(maxlength) &amp;amp;&amp;amp; maxlength &amp;gt; 0){
            var realLen = encodeURIComponent($that.val()).replace(/%[A-F\d]{2}/g, &#39;U&#39;).length;
            var newLines = $that.val().match(/(\r\n|\n|\r)/g);

            if (newLines !== null) {
                realLen += newLines.length;
            }
            var currLen = $that.val().length;
            if (realLen &amp;gt; maxlength) {
                do {
                    $that.val($that.val().substr(0, currLen));
                    currLen --;
                    realLen = encodeURIComponent($that.val()).replace(/%[A-F\d]{2}/g, &#39;U&#39;).length;
                    newLines = $that.val().match(/(\r\n|\n|\r)/g);
                    if (newLines !== null) {
                        realLen += newLines.length;
                    }
                } while (realLen &amp;gt; maxlength);
            }
        };
    });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上述代码已完整测试，中文、英文、中英文混合、复制粘贴等等，都能按照maxlength的值精确控制用户输入的长度了。&lt;/p&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;见微知著，看似不大的问题却涵盖很广的知识面。就是这样，注意细节问题，才能不断进步。厚积薄发，注意小问题，更不轻易放过，放过了小问题，对你来说就是大问题了。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>同步、异步、阻塞、非阻塞I/O</title>
      <link>http://compasses.github.io/2015/05/24/%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9Ei/o/</link>
      <pubDate>Sun, 24 May 2015 14:45:07 +0800</pubDate>
      <author>gnhe2009@gmail.com (Jet He)</author>
      <guid>http://compasses.github.io/2015/05/24/%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9Ei/o/</guid>
      <description>&lt;p&gt;NodeJS倡导异步编程，高并发，高性能。他自然是异步非阻塞I/O。非阻塞I/O是不是就是异步的，跟异步编程又有什么区别呢？写到这里突然想到了大学里的辅导员，刚入大学的第一次开会，就告诫我们，&lt;strong&gt;学数学最重要的就是概念，概念不清就什么都学不好&lt;/strong&gt;。我深深记住了这句话，受用至今。&lt;/p&gt;

&lt;p&gt;先看看阻塞和非阻塞，阻塞，顾名思义，即在读取数据时，阻塞在等待数据，或者监听事件时阻塞，有新的数据或者事件，事件是泛化概念，数据到达也是个事件。可以用事件代替一切吧，统称event。非阻塞即调用接口触发某种event，没有任何event也不会阻塞，而是直接返回。&lt;/p&gt;

&lt;p&gt;非阻塞返回后干什么，这就牵扯到同步和异步之分了。阻塞就不用多说了显而易见的同步行为。在非阻塞的基础上再进行区分同步和异步。非阻塞在Linux上一般都会使用性能较好的epoll实现，epoll会轮询这些阻塞上的事件，有事务返回便会调用相应的处理流程。那这个是不是异步的呢，还是要看在哪个角度上说，站在非阻塞的角度上，因同时处理多个事件，增加并发性，多个阻塞event进行了异步处理；在轮询线程上说，因还是在不断的轮询它所关心的事件，某一个事件返回时就要进行相应的处理，在这个角度上讲，这个线程可以同步处理多个异步事件，它是同步的。但是在一个框架上，如果实现了这种同步处理多个异步事件的行为，在基于这个框架上进行编码的时候，要进行事件回调，这也是NodeJS的行为。NodeJS需要异步编程思想，但是NodeJS是单线程的，NodeJS就是要不断回调那些需要异步处理的事件，但是异步编程会让代码变得难以维护和调试，&lt;a href=&#34;http://www.zhihu.com/question/19585576&#34;&gt;这个链接&lt;/a&gt;有较好的讨论。&lt;/p&gt;

&lt;p&gt;AIO是纯正的异步I/O且非阻塞的，本来应该想epoll一样被广泛使用，获得大赞的，但目前看来被&lt;a href=&#34;http://www.wzxue.com/linux-kernel-aio%E8%BF%99%E4%B8%AA%E5%A5%87%E8%91%A9/&#34;&gt;诟病太多&lt;/a&gt;。例如内核实现的AIO只能是直接I/O的方式，不能有效的利用系统缓存。glibc的AIO利用线程池模拟出来的，但是存在一系列的bug和&lt;a href=&#34;http://www.lenky.info/archives/2013/01/2165&#34;&gt;缺陷&lt;/a&gt;。也因此NodeJS的作者重新封装了一个异步非阻塞的库： libuv。&lt;/p&gt;

&lt;p&gt;由于NodeJS的异步编程思想，会让代码变得维护困难，调试也非常不直观，后面就出现了协程的思想。&lt;a href=&#34;https://bjouhier.wordpress.com/2012/03/11/fibers-and-threads-in-node-js-what-for/&#34;&gt;这篇文章&lt;/a&gt;对NodeJS的协程思想进行了介绍。&lt;a href=&#34;https://github.com/laverdet/node-fibers&#34;&gt;node-fibers&lt;/a&gt;尝试去协程花NodeJS的层层回调。这个module值得研究一下。后续会有个单独的文章对其进行详细的介绍。&lt;/p&gt;

&lt;p&gt;NodeJS底层事件循环使用了libuv库，跨平台Linux下使用libev实现，windows下使用IOCP实现，后续也要仔细研究下这个库，应用广泛的东西，必定是好东西，值得学习的东西。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>