<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Web 前端 on 三十重围</title>
    <link>http://compasses.github.io/tags/web-%E5%89%8D%E7%AB%AF/</link>
    <description>Recent content in Web 前端 on 三十重围</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-EN</language>
    <managingEditor>gnhe2009@gmail.com (Jet He)</managingEditor>
    <webMaster>gnhe2009@gmail.com (Jet He)</webMaster>
    <copyright>(c) 2015 Jet He.</copyright>
    <lastBuildDate>Wed, 05 Aug 2015 20:45:07 +0800</lastBuildDate>
    <atom:link href="http://compasses.github.io/tags/web-%E5%89%8D%E7%AB%AF/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>前端经验</title>
      <link>http://compasses.github.io/2015/08/05/%E5%89%8D%E7%AB%AF%E7%BB%8F%E9%AA%8C/</link>
      <pubDate>Wed, 05 Aug 2015 20:45:07 +0800</pubDate>
      <author>gnhe2009@gmail.com (Jet He)</author>
      <guid>http://compasses.github.io/2015/08/05/%E5%89%8D%E7%AB%AF%E7%BB%8F%E9%AA%8C/</guid>
      <description>

&lt;p&gt;最近还是比较忙，blog好久没有写了，当然也不排除自己有点懈怠。也没有什么太多要写的，就是些工作上的事情。最近做前端比较多，还是就写写前端的一些经验吧。之前也说过，前端就是一个积累的过程，另外多借鉴一些成熟的前端框架会对自己的水平提高很有帮助。&lt;/p&gt;

&lt;h1 id=&#34;css相关&#34;&gt;CSS相关&lt;/h1&gt;

&lt;p&gt;因为开发是基于LESS的，所以代码相关的都是&lt;a href=&#34;http://less.bootcss.com/&#34;&gt;LESS&lt;/a&gt;的代码。
##mixin
可以看作是面向对象的CSS，直白的讲就是混合引入，也有翻译是混入或混合，这样感觉都是很模糊的。其实功能上就是定义一组属性、style在一个mixin中，可以让其他的class直接引用，作为公共的基础class。例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.ellipsis (@width) {
  width: @width;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个ellipsis class会将定宽文本进行截断，这样的class可能会在网站中多处使用，而且每次使用宽度可变，这样在使用时传入想要宽度的参数即可。例如产品名字的class：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;product-name {
     .ellipsis(8em);
     ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;media&#34;&gt;media&lt;/h2&gt;

&lt;p&gt;由于前端一直在使用&lt;a href=&#34;http://v3.bootcss.com/css/&#34;&gt;bootstrap&lt;/a&gt;，所以所有的responsive相关的design都是依赖bootstrap来实现。bootstrap的栅格系统需要一定的使用规则，有的时候过度使用会导致DOM结构过去复杂化了。例如其中的form，form里面必须按照一个input一个label的排列，如果想要添加一些文本信息或者增加其他的标签，又让他保持responsive，必须通过类似row下的col再嵌套row和col，这样就实现很复杂，让DOM结构看起来混乱不堪。
其实看看bootstrap.css里面的代码也不难发现，其实responsive的代码也不难写，问题是你不需要去写一个框架，框架的代码是普适的。你只是为了满足一个小特性，所以代码也会写的很精简。&lt;/p&gt;

&lt;p&gt;使用&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/CSS/@media&#34;&gt;media query&lt;/a&gt; 来索引屏幕尺寸并进行特定class的apply。可以让网页支持较好的自适应性。例如针对小屏幕某个class需要有些自适应的属性，下面这个css class在小屏幕上，屏幕宽度小于767px时，左侧增加20px的margin。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.class-name {
     @media(max-width: 767px) {
          margin-left: 20px;
          ...
     }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面是在class里面进行屏幕适应，更多的时候是定义整个class为自适应：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@media only screen and (max-width: 767px) {
     .class-name {
          ...
     }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;根据不同的尺寸class里面的style进行相应的变化。bootstrap也是这么玩的。
在移动设备上有横屏和竖屏的区分，也能做相应的自适应。
关键的属性：&lt;/p&gt;

&lt;p&gt;| media 属性     | 结果|
| &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;- |:&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-:|
| min-width      |  当任意浏览器宽度大于查询中定义的值时适用的规则。 |
| max-width      | 当任意浏览器宽度小于查询中定义的值时适用的规则。 |
| min-height | 当任意浏览器高度大于查询中定义的值时适用的规则。    |
| max-height | 当任意浏览器高度小于查询中定义的值时适用的规则。|
| orientation=portrait| 高度大于或等于宽度的任意浏览器适用的规则。相当于竖屏。|
| orientation=landscape| 宽度大于高度的任意浏览器适用的规则。相当于横屏。|&lt;/p&gt;

&lt;h2 id=&#34;语义化标签&#34;&gt;语义化标签&lt;/h2&gt;

&lt;p&gt;写一些复杂网页的时候，DOM元素的选取至关重要。要尽量结合Object的属性，进行语义上的对应选择，多使用语义化的标签。例如一个product detail页面，product属性是非常复杂的，有多个variant，variant下面有多个value。当选择variant和对应的value 的时候，就能确定一个单品，这时还会有多个事件的处理，例如每个单品的价格、库存都是变化的，产品的variant对应有相应的产品图片。
这样的DOM结构，全部使用div能做出来吗，肯定能做出来，但是复杂度就上去了。因为要兼顾前端UI的展示、JS的交互等等。通过观察多个电商网站的DOM结构，也能发现，大部分是使用：dl dt dd + ul li。即外层展示使用dl dt，dd里面套上ul + li 展示具体的variant value，这样的DOM结构清晰，CSS class的selector也很容易写，包括JS的也是一样的。&lt;/p&gt;

&lt;p&gt;上面只是简单举个实际过程中遇到的例子。其实语义化标签的使用包含很多其他的东西；随着经验的积累使用起来也会更加得心应手。&lt;/p&gt;

&lt;h1 id=&#34;js相关&#34;&gt;JS相关&lt;/h1&gt;

&lt;p&gt;JS遵从语言规范外，对单个页面使用的JS进行封装，让代码看起来不是太过去杂乱。如果前端的JS使用了框架应该不存在这样的问题。
封装的时候要对照页面的DOM结构和交互流程，让Object能更好为事件响应服务。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>WEB 开发点滴</title>
      <link>http://compasses.github.io/2015/07/07/web-%E5%BC%80%E5%8F%91%E7%82%B9%E6%BB%B4/</link>
      <pubDate>Tue, 07 Jul 2015 20:45:07 +0800</pubDate>
      <author>gnhe2009@gmail.com (Jet He)</author>
      <guid>http://compasses.github.io/2015/07/07/web-%E5%BC%80%E5%8F%91%E7%82%B9%E6%BB%B4/</guid>
      <description>

&lt;p&gt;WEB开发错综复杂，很多知识点让你抓不到重点，用过了忘记了，下次用还要重头开始。例如CSS，很多class，很多的取值，每个都有很多视觉效果。拿到UX的design，不同的人做出来的效果可以保持一致，但是对应的CSS和JS可能完全不一样。正是这种WEB开发的灵活性，更让人抓不到重点。&lt;/p&gt;

&lt;p&gt;最近又在做一些UI的开发工作，集中在前端，需要CSS和JS，事情做完了，仔细想想里面用到的CSS class都理解了吗？发现并没用。如此众多，如何才能掌握这些class呢？突然想到CSS class虽然众多但是用到的不是全集，所以在学习上也要化整为零，化繁为简，各个击破。这次就好好记录下CSS中的overflow和position类。&lt;/p&gt;

&lt;h1 id=&#34;position&#34;&gt;POSITION&lt;/h1&gt;

&lt;p&gt;解释说明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;position
    
&#39;position&#39;
Value:  
static | relative | absolute | fixed | inherit
Initial:  
static
Applies to:  
all elements
Inherited:  
no
Percentages:  
N/A
Media:  
visual
Computed value:  
as specified
The values of this property have the following meanings:
static
The box is a normal box, laid out according to the normal flow. The &#39;top&#39;, &#39;right&#39;, &#39;bottom&#39;, and &#39;left&#39; properties do not apply.
relative
The box&#39;s position is calculated according to the normal flow (this is called the position in normal flow). Then the box is offset relative to its normal position. When a box B is relatively positioned, the position of the following box is calculated as though B were not offset. The effect of &#39;position:relative&#39; on table-row-group, table-header-group, table-footer-group, table-row, table-column-group, table-column, table-cell, and table-caption elements is undefined.
absolute
The box&#39;s position (and possibly size) is specified with the &#39;top&#39;, &#39;right&#39;, &#39;bottom&#39;, and &#39;left&#39; properties. These properties specify offsets with respect to the box&#39;s containing block. Absolutely positioned boxes are taken out of the normal flow. This means they have no impact on the layout of later siblings. Also, though absolutely positioned boxes have margins, they do not collapse with any other margins.
fixed
The box&#39;s position is calculated according to the &#39;absolute&#39; model, but in addition, the box is fixed with respect to some reference. As with the &#39;absolute&#39; model, the box&#39;s margins do not collapse with any other margins. In the case of handheld, projection, screen, tty, and tv media types, the box is fixed with respect to the viewport and doesn&#39;t move when scrolled. In the case of the print media type, the box is rendered on every page, and is fixed with respect to the page box, even if the page is seen through a viewport (in the case of a print-preview, for example). For other media types, the presentation is undefined. Authors may wish to specify &#39;fixed&#39; in a media-dependent way. For instance, an author may want a box to remain at the top of the viewport on the screen, but not at the top of each printed page. The two specifications may be separated by using an @media rule, as in:
Example(s):
  
@media screen {
  h1#first { position: fixed }
}
@media print {
  h1#first { position: static }
}
UAs must not paginate the content of fixed boxes. Note that UAs may print invisible content in other ways. See &amp;quot;Content outside the page box&amp;quot; in chapter 13.
User agents may treat position as &#39;static&#39; on the root element.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;元素的位置定位影响它的视觉模型，例如：p, h1, div 为块级元素，块级元素在展示的时候是以垂直摆放的，元素之间的垂直距离由垂直间隔决定，即margin。又如：strong、span为inline elements，内联元素。展示为水平摆放，这种元素改变视觉效果只能通过line height、或者水平 border 、padding、margin。&lt;/p&gt;

&lt;h2 id=&#34;relative-position&#34;&gt;relative position&lt;/h2&gt;

&lt;p&gt;相对定位比较简单，就是可以通过属性 top、left、bottom、right来改变它的位置，改变是相对于它的原始位置开始计算的。它于正常的文档流定位类似。跟position的另一个取值static一样，如果不改变它的位置属性值。&lt;/p&gt;

&lt;h2 id=&#34;absolute-position&#34;&gt;absolute position&lt;/h2&gt;

&lt;p&gt;类似于relative position，absolute position是相对于其最近的父节点而摆放。如果没有最近的父节点，就绑定在body元素上。absolute position让其父节点必须是relative position。&lt;/p&gt;

&lt;h2 id=&#34;fixed-position&#34;&gt;fixed position&lt;/h2&gt;

&lt;p&gt;是absolute position的子类，不同的是它的视口是整个window， 利用它就可以固定一个元素在这个窗口视图上，无论怎么滚动这个元素会固定在这个窗口中。&lt;/p&gt;

&lt;h2 id=&#34;floating&#34;&gt;floating&lt;/h2&gt;

&lt;p&gt;floatting也是重要的布局类，经常需要将一个元素靠左或者靠右对齐。靠左或者靠右直到它的外边缘与父节点边缘接壤，或者其他float元素的边缘。float元素并不在正常的文档流中。即只要元素变为float元素了，其所在的body就会将其视为不存在了。在实现那些文字环绕的效果时，都会使用到这个class，因为float元素会脱离正常的文档流，所以在制作这种效果的时候需要用clear配合使用。&lt;/p&gt;

&lt;h1 id=&#34;overflow&#34;&gt;overflow&lt;/h1&gt;

&lt;p&gt;解释：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;overflow
    
&#39;overflow&#39;
Value:  
visible | hidden | scroll | auto | inherit
Initial:  
visible
Applies to:  
non-replaced block-level elements, table cells, and inline-block elements
Inherited:  
no
Percentages:  
N/A
Media:  
visual
Computed value:  
as specified
This property specifies whether content of a block-level element is clipped when it overflows the element&#39;s box. It affects the clipping of all of the element&#39;s content except any descendant elements (and their respective content and descendants) whose containing block is the viewport or an ancestor of the element. Values have the following meanings:
visible
This value indicates that content is not clipped, i.e., it may be rendered outside the block box.
hidden
This value indicates that the content is clipped and that no scrolling user interface should be provided to view the content outside the clipping region.
scroll
This value indicates that the content is clipped and that if the user agent uses a scrolling mechanism that is visible on the screen (such as a scroll bar or a panner), that mechanism should be displayed for a box whether or not any of its content is clipped. This avoids any problem with scrollbars appearing and disappearing in a dynamic environment. When this value is specified and the target medium is &#39;print&#39;, overflowing content may be printed.
auto
The behavior of the &#39;auto&#39; value is user agent-dependent, but should cause a scrolling mechanism to be provided for overflowing boxes.
Even if &#39;overflow&#39; is set to &#39;visible&#39;, content may be clipped to a UA&#39;s document window by the native operating environment.
UAs must apply the &#39;overflow&#39; property set on the root element to the viewport. HTML UAs must instead apply the &#39;overflow&#39; property from the BODY element to the viewport, if the value on the HTML element is &#39;visible&#39;. The &#39;visible&#39; value when used for the viewport must be interpreted as &#39;auto&#39;. The element from which the value is propagated must have a used value for &#39;overflow&#39; of &#39;visible&#39;.
In the case of a scrollbar being placed on an edge of the element&#39;s box, it should be inserted between the inner border edge and the outer padding edge. The space taken up by the scrollbars affects the computation of the dimensions in the rendering model.
Example(s):
Consider the following example of a block quotation (&amp;lt;blockquote&amp;gt;) that is too big for its containing block (established by a &amp;lt;div&amp;gt;). Here is the source:
&amp;lt;div&amp;gt;
&amp;lt;blockquote&amp;gt;
&amp;lt;p&amp;gt;I didn&#39;t like the play, but then I saw
it under adverse conditions - the curtain was up.&amp;lt;/p&amp;gt;
&amp;lt;cite&amp;gt;- Groucho Marx&amp;lt;/cite&amp;gt;
&amp;lt;/blockquote&amp;gt;
&amp;lt;/div&amp;gt;
Here is the style sheet controlling the sizes and style of the generated boxes:
div { width : 100px; height: 100px;
      border: thin solid red;
      }

blockquote   { width : 125px; height : 100px;
      margin-top: 50px; margin-left: 50px;
      border: thin dashed black
      }

cite { display: block;
       text-align : right;
       border: none
       }
The initial value of &#39;overflow&#39; is &#39;visible&#39;, so the &amp;lt;blockquote&amp;gt; would be formatted without clipping, something like this:
   [D]
Setting &#39;overflow&#39; to &#39;hidden&#39; for the &amp;lt;div&amp;gt;, on the other hand, causes the &amp;lt;blockquote&amp;gt; to be clipped by the containing block:
   [D]
A value of &#39;scroll&#39; would tell UAs that support a visible scrolling mechanism to display one so that users could access the clipped content.
Finally, consider this case where an absolutely positioned element is mixed with an overflow parent.
Style sheet:
  container { position: relative; border: solid; }
  scroller { overflow: scroll; height: 5em; margin: 5em; }
  satellite { position: absolute; top: 0; }
  body { height: 10em; }
Document fragment:
  &amp;lt;container&amp;gt;
   &amp;lt;scroller&amp;gt;
    &amp;lt;satellite/&amp;gt;
    &amp;lt;body/&amp;gt;
   &amp;lt;/scroller&amp;gt;
  &amp;lt;/container&amp;gt;
In this example, the &amp;quot;scroller&amp;quot; element will not scroll the &amp;quot;satellite&amp;quot; element, because the latter&#39;s containing block is outside the element whose overflow is being clipped and scrolled.
11.1. The ‘overflow’, ‘overflow-x’ and ‘overflow-y’ properties
In the preceding sections, several things (such as flow roots) depend on the value of ‘overflow’. We probably need to rewrite them in terms of “overflow-x and/or -y” or similar.
Name:
overflow-x, overflow-y,
Value:
visible | hidden | scroll | auto | no-display | no-content
Initial:
visible
Applies to:
non-replaced block-level elements and non-replaced ‘inline-block’ elements
Inherited:
no
Percentages:
N/A
Media:
visual
Computed value:
as specified, except ‘visible’, see text
Name:
overflow
Value:
[ visible | hidden | scroll | auto | no-display | no-content ]{1,2}
Initial:
see individual properties
Applies to:
non-replaced block-level elements and non-replaced ‘inline-block’ elements
Inherited:
no
Percentages:
N/A
Media:
visual
Computed value:
as specified, except ‘visible’, see text
These properties specify whether content is clipped when it overflows the element&#39;s content area. It affects the clipping of all of the element&#39;s content except any descendant elements (and their respective content and descendants) whose containing block is the viewport or an ancestor of the element. ‘Overflow-x’ determines clipping at the left and right edges, ‘overflow-y’ at the top and bottom edges.
‘Overflow’ is a shorthand. If it has one keyword, it sets both ‘overflow-x’ and ‘overflow-y’ to that keyword; if it has two, it sets ‘overflow-x’ to the first and ‘overflow-y’ to the second. Keywords have the following meanings:
visible
This value indicates that content is not clipped, i.e., it may be rendered outside the content box.
hidden
This value indicates that the content is clipped and that no scrolling mechanism should be provided to view the content outside the clipping region.
scroll
This value indicates that the content is clipped and that if the user agent uses a scrolling mechanism that is visible on the screen (such as a scroll bar or a panner), that mechanism should be displayed for a box whether or not any of its content is clipped. This avoids any problem with scrollbars appearing and disappearing in a dynamic environment. When this value is specified and the target medium is ‘print’, overflowing content may be printed.
auto
The behavior of the ‘auto’ value is UA-dependent, but should cause a scrolling mechanism to be provided for overflowing boxes.
no-display
When the content doesn&#39;t fit in the content box, the whole box is removed, as if ‘display: none’ were specified. [This idea is due to Till Halbach &amp;lt;tillh@opera.com&amp;gt;, July 21, 2005]
no-content
When the content doesn&#39;t fit in the content box, the whole content is hidden, as if ‘visibility: hidden’ were specified. [This idea is due to Till Halbach &amp;lt;tillh@opera.com&amp;gt;, July 21, 2005]
Even if ‘overflow’ is set to ‘visible’, content may be clipped to a UA&#39;s document window by the native operating environment.
UAs must apply the ‘overflow’ property set on the root element to the viewport. HTML UAs must instead apply the ‘overflow’ property from the BODY element to the viewport, if the value on the HTML element is ‘visible’. The ‘visible’ value when used for the viewport must be interpreted as ‘auto’. The element from which the value is propagated must have a used value for ‘overflow’ of ‘visible’.
The para above is from CSS 2.1. Need to check if the introduction of overflow-x/y changes anything.
In the case of a scrollbar being placed on an edge of the element&#39;s box, it should be inserted between the inner border edge and the outer padding edge. The space taken up by the scrollbars affects the computation of the dimensions in the rendering model.
A UA may use multiple scrolling mechanisms at the same time. E.g., if content overflows both to the right and to the bottom, it may use a marquee effect for the overflow to the right and a scrollbar for the overflow to the bottom.
Note that a box with ‘overflow’ other than ‘visible’ is a flow root.
Consider the following example of a block quotation (&amp;lt;blockquote&amp;gt;) that is too big for its containing block (established by a &amp;lt;div&amp;gt;). Here is the source:
&amp;lt;div&amp;gt;
&amp;lt;blockquote&amp;gt;
&amp;lt;p&amp;gt;I didn&#39;t like the play, but then I saw
it under adverse conditions - the curtain was up.&amp;lt;/p&amp;gt;
&amp;lt;cite&amp;gt;- Groucho Marx&amp;lt;/cite&amp;gt;
&amp;lt;/blockquote&amp;gt;
&amp;lt;/div&amp;gt;
Here is the style sheet controlling the sizes and style of the generated boxes:
div { width : 100px; height: 100px;
      border: thin solid red;
      }

blockquote   { width : 125px; height : 100px;
      margin-top: 50px; margin-left: 50px;
      border: thin dashed black
      }

cite { display: block;
       text-align : right;
       border: none
       }
The initial value of ‘overflow’ is ‘visible’, so the &amp;lt;blockquote&amp;gt; would be formatted without clipping, something like this:

Possible rendering with ‘overflow: visible’
Setting ‘overflow’ to ‘hidden’ for the &amp;lt;div&amp;gt;, on the other hand, causes the &amp;lt;blockquote&amp;gt; to be clipped by the containing block:

Possible rendering with ‘overflow: hidden’
A value of ‘scroll’ would tell UAs that support a visible scrolling mechanism to display one so that users could access the clipped content.
Consider this case where an absolutely positioned element is mixed with an overflow parent. Style sheet:
container { position: relative; border: solid; }
scroller { overflow: scroll; height: 5em; margin: 5em; }
satellite { position: absolute; top: 0; }
body { height: 10em; }
Document fragment:
&amp;lt;container&amp;gt;
&amp;lt;scroller&amp;gt;
  &amp;lt;satellite/&amp;gt;
  &amp;lt;body/&amp;gt;
&amp;lt;/scroller&amp;gt;
&amp;lt;/container&amp;gt;
In this example, the “scroller” element will not scroll the “satellite” element, because the latter&#39;s containing block is outside the element whose overflow is being clipped and scrolled.
The combination of collapsing margins, ‘max-height’ and ‘overflow: auto’ can lead to subtle differences in implementations, unless special care is taken. A UA should assume that an element can be rendered without a scrolling mechanism first, perform all the collapsing of margins, and check that the content height is indeed less than the ‘max-height’. If it is not, the process is repeated under the assumption that a scrolling mechanism is needed.
In the following document fragment, the outer DIV has ‘height: auto’, but ‘max-height: 5em’. The inner DIV has large margins and would normally just fit:
...
    #d1 { overflow: auto; max-height: 5em }
    #d2 { margin: 2em; line-height: 1 }
...
&amp;lt;div id=d1&amp;gt;
  &amp;lt;div id=d2&amp;gt;
    This DIV has big margins.
  &amp;lt;/DIV&amp;gt;
&amp;lt;/DIV&amp;gt;
If we assume that d1 needs scroll bars, then the height of d1, including the single line of text and twice 2em of margins, adds up to 5em plus a scrollbar. Since that is greater than 5em, the maximum allowed height, it seems we made the right assumption and d1 indeed needs scrollbars.
However, we should have started by assuming that no scrollbars are needed. In that case the content height of d1 is exactly the maximum height of 5em, proving that the assumption was correct and d1 indeed should not have scrollbars.
The computed values of ‘overflow-x’ and ‘overflow-y’ are the same as their specified values, except that some combinations with ‘visible’ are not possible: if one is specified as ‘visible’ and the other is ‘scroll’ or ‘auto’, then ‘visible’ is set to ‘auto’. The computed value of ‘overflow’ is equal to the computed value of ‘overflow-x’ if ‘overflow-y’ is the same; otherwise it is the pair of computed values of ‘overflow-x’ and ‘overflow-y’.
The scrolling mechanism depends on the UA. The most common mechanism is a scrollbar, but panners, hand cursors, page flickers, etc. are also possible. A value of ‘scroll’ would tell UAs that support a visible scrolling mechanism to display one so that users can access the clipped content. The ‘overflow-style’ property lets an author specify one or more preferred scrolling mechanism.
Note that ‘overflow-x’ and ‘overflow-y’ did not exist in CSS2.
Note that ‘text-overflow’ (see [CSS3TEXT] ) can be used to give a visual indication where text has been clipped.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;overflow，常与定高的元素配合使用，如果元素定高，通过overflow-y: auto, 如果内容高度大于定高元素就会出现滚动条。如果定高元素内部需要出现overflow：visiable的元素，需要重新更改overflow的属性值。因为默认元素的overflow是继承父节点的。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>